<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BYOB One – Minimal Wallet</title>
    <style>
        body { font-family: sans-serif; max-width: 480px; margin: auto; padding: 20px; }
        .screen { display:none; }
        .screen.active { display:block; }
        input, button, textarea { font-size:16px; padding:8px; margin:5px 0; width:100%; box-sizing:border-box; }
        canvas { display:block; margin:10px auto; }
        .network-toggle { margin-bottom:10px; }
        #xpubScanner, #destScanner { width:100%; height:300px; display:none; border:1px solid #ccc; margin-top:10px; }
        .warning { color:red; font-size:14px; margin-top:5px; }
    </style>
</head>
<body>
    <h2>BYOB One – Minimal Wallet</h2>
    <div class="network-toggle">
        <label><input type="radio" name="network" value="mainnet"> Mainnet</label>
        <label><input type="radio" name="network" value="testnet" checked> Testnet</label>
    </div>

    <!-- WALLET SCREEN -->
    <div id="walletScreen" class="screen active">
        <div id="xpubImportSection">
            <input type="text" id="xpubInput" placeholder="Paste XPUB here">
            <button onclick="saveXpub()">Save XPUB</button>
            <button onclick="startXpubScan()">Scan XPUB QR</button>
            <div id="xpubScanner"></div>
            <div id="cameraWarning" class="warning"></div>
        </div>
        <div id="walletInfoSection" style="display:none;">
            <p><strong>Balance:</strong> <span id="balanceDisplay"></span></p>
            <p><strong>Next Receive Address:</strong></p>
            <p id="receiveAddress"></p>
            <canvas id="receiveQR" width="220" height="220"></canvas>
            <button onclick="goToSend()">Send BTC</button>
        </div>
    </div>

    <!-- SEND SCREEN -->
    <div id="sendScreen" class="screen">
        <p><strong>Destination Address:</strong></p>
        <input type="text" id="destAddress">
        <button onclick="startDestScan()">Scan Destination QR</button>
        <div id="destScanner"></div>
        <div id="destWarning" class="warning"></div>
        <p><strong>Amount (sats):</strong></p>
        <input type="number" id="sendAmount">
        <p><strong>Fee rate (sat/vbyte):</strong></p>
        <input type="range" id="feeSlider" min="1" max="200" value="10" oninput="document.getElementById('feeValue').innerText = this.value">
        <span id="feeValue">10</span> sat/vB
        <button onclick="buildTx()">Build TX</button>
        <button onclick="goToWallet()">Back</button>
    </div>

    <!-- SIGN SCREEN -->
    <div id="signScreen" class="screen">
        <p>Unsigned TX hex:</p>
        <textarea id="unsignedTx" rows="6"></textarea>
        <p>Paste signed TX hex:</p>
        <textarea id="signedTx" rows="6"></textarea>
        <button onclick="broadcastTx()">Broadcast TX</button>
        <button onclick="goToWallet()">Back</button>
        <div id="txStatus"></div>
    </div>

    <!-- LIBRARIES (STATIC + STABLE) -->
    <!-- NOTE: You must have these files in a 'js' subdirectory for this to work -->
    <script src="js/buffer.min.js"></script>
    <script> window.Buffer = window.buffer.Buffer; </script>
    <script src="js/bip32.min.js"></script>
    <script src="js/bitcoinjs-lib.min.js"></script>
    <script src="js/qrcode.min.js"></script>
    <script src="js/html5-qrcode.min.js"></script>



<script>
    // ------------------------------
    // 1. ADOPT: Global Library Shims for Robustness
    // ------------------------------
    // This makes the app more resilient to different library versions or loading orders.
    window.bip32 = window.bip32 || window.scureBip32;
    window.bitcoin = window.bitcoin || window.bitcoinjs || window.Bitcoin;
    window.Buffer = window.Buffer || window.buffer?.Buffer;
    
    const { networks, payments, Psbt } = bitcoin;
    let currentNetwork = "testnet";
    let derivedAddresses = [];
    let utxos = [];
    const walletScreen = document.getElementById("walletScreen");
    const sendScreen = document.getElementById("sendScreen");
    const signScreen = document.getElementById("signScreen");

    function showScreen(screen){
        document.querySelectorAll('.screen').forEach(s=>s.classList.remove("active"));
        screen.classList.add("active");
    }
    function goToSend(){ showScreen(sendScreen); }
    function goToWallet(){ showScreen(walletScreen); }
    function goToSign(){ showScreen(signScreen); }

    document.querySelectorAll('input[name="network"]').forEach(radio=>{
        radio.addEventListener("change",()=>{
            currentNetwork = radio.value;
            loadWallet();
        });
    });

    function getNetwork(){ return currentNetwork==="mainnet"?networks.bitcoin:networks.testnet; }
    function getApi(){ return currentNetwork==="mainnet"? "https://mempool.space/api": "https://mempool.space/testnet/api"; }
    function getStorageKey(){ return "byob_xpub_"+currentNetwork; }

    // ------------------------------
    // 2. INTEGRATE: Robust Validation into saveXpub
    // ------------------------------


function saveXpub(){
    const xpubInput = document.getElementById("xpubInput");
    const xpub = xpubInput.value.trim();
    if (!xpub) return alert("Enter XPUB");

    let xpubNetwork; // The network the XPUB belongs to

    try {
        // 1. Determine network from the XPUB prefix
        if (xpub.startsWith("xpub")) {
            xpubNetwork = bitcoin.networks.bitcoin;
        } else if (xpub.startsWith("tpub")) {
            xpubNetwork = bitcoin.networks.testnet;
        } else {
            throw new Error("XPUB must start with 'xpub' (mainnet) or 'tpub' (testnet).");
        }

        // 2. Validate the XPUB against its own network
        bip32.fromBase58(xpub, xpubNetwork);

        // 3. Test localStorage
        localStorage.setItem("test_xpub", xpub);
        if (localStorage.getItem("test_xpub") !== xpub) {
            throw new Error("localStorage is not available or full.");
        }
        localStorage.removeItem("test_xpub");

        // 4. If the XPUB's network doesn't match the UI, switch the UI and warn the user
        if ((xpubNetwork === bitcoin.networks.bitcoin && currentNetwork !== "mainnet") ||
            (xpubNetwork === bitcoin.networks.testnet && currentNetwork !== "testnet")) {
            
            const networkName = xpubNetwork === bitcoin.networks.bitcoin ? "mainnet" : "testnet";
            if (!confirm(`This is a ${networkName} XPUB, but you have ${currentNetwork} selected. Switch to ${networkName}?`)) {
                return; // User cancelled
            }
            // Update the UI radio button and the global variable
            document.querySelector(`input[name="network"][value="${networkName}"]`).checked = true;
            currentNetwork = networkName;
        }

        // 5. If all checks pass, save the XPUB and reload the wallet
        localStorage.setItem(getStorageKey(), xpub);
        loadWallet();

    } catch (err) {
        console.error("XPUB Validation Error:", err);
        alert("Invalid XPUB: " + err.message);
    }
}


    async function loadWallet(){
        const xpub=localStorage.getItem(getStorageKey());
        if(!xpub){
            document.getElementById("xpubImportSection").style.display="block";
            document.getElementById("walletInfoSection").style.display="none";
            return;
        }
        document.getElementById("xpubImportSection").style.display="none";
        document.getElementById("walletInfoSection").style.display="block";
        document.getElementById("balanceDisplay").innerText="Loading...";
        try {
            await deriveAddresses(xpub);
            await fetchBalance();
        } catch (e) {
            console.error("Failed to load wallet", e);
            document.getElementById("balanceDisplay").innerText = "Error loading wallet";
            alert("Could not load wallet. See console.");
        }
    }

    // ------------------------------
    // 3. KEEP: The existing multi-address derivation logic
    // ------------------------------
    async function deriveAddresses(xpub){
        derivedAddresses=[];
        const node=bip32.fromBase58(xpub,getNetwork());
        for(let i=0;i<20;i++){
            const child=node.derive(0).derive(i);
            const {address}=payments.p2wpkh({ pubkey:child.publicKey, network:getNetwork() });
            derivedAddresses.push(address);
        }
    }

    async function fetchBalance(){
        utxos=[];
        let total=0;
        for(let addr of derivedAddresses){
            try {
                const res=await fetch(`${getApi()}/address/${addr}/utxo`);
                if (!res.ok) throw new Error(`API error for ${addr}: ${res.statusText}`);
                const data=await res.json();
                data.forEach(u=>{
                    utxos.push({...u, address: addr});
                    total+=u.value;
                });
            } catch (e) {
                console.error(`Failed to fetch balance for \${addr}:`, e);
            }
        }
        document.getElementById("balanceDisplay").innerText= total.toLocaleString()+" sats";
        displayReceive();
    }

    function displayReceive(){
        const addr=derivedAddresses[0];
        document.getElementById("receiveAddress").innerText=addr;
        QRCode.toCanvas( document.getElementById("receiveQR"), addr, { width:220 }, (error) => {
            if (error) console.error(error);
        });
    }

    function startXpubScan(){
        const scannerDiv=document.getElementById("xpubScanner");
        const warningDiv=document.getElementById("cameraWarning");
        scannerDiv.style.display="block";
        warningDiv.innerText = "";
        const html5QrCode=new Html5Qrcode("xpubScanner");
        html5QrCode.start(
            { facingMode:"environment" },
            { fps:10, qrbox:250 },
            txt=>{
                html5QrCode.stop().then(() => {
                    scannerDiv.style.display="none";
                    document.getElementById("xpubInput").value=txt;
                    saveXpub(); // This will now trigger the enhanced validation
                }).catch(err => {
                    console.error("Failed to stop scanner", err);
                    warningDiv.innerText = "Error stopping scanner.";
                });
            },
            err=> { /* Silently ignore scan errors */ }
        ).catch(err => {
            console.error("Unable to start scanning.", err);
            warningDiv.innerText = "Cannot start camera. Use HTTPS or allow camera access.";
        });
    }

    function startDestScan(){
        const scannerDiv=document.getElementById("destScanner");
        const warningDiv=document.getElementById("destWarning");
        scannerDiv.style.display="block";
        warningDiv.innerText = "";
        const html5QrCode=new Html5Qrcode("destScanner");
        html5QrCode.start(
            { facingMode:"environment" },
            { fps:10, qrbox:250 },
            txt=>{
                html5QrCode.stop().then(() => {
                    scannerDiv.style.display="none";
                    document.getElementById("destAddress").value=txt;
                }).catch(err => {
                    console.error("Failed to stop destination scanner", err);
                    warningDiv.innerText = "Error stopping scanner.";
                });
            },
            err=> { /* Silently ignore scan errors */ }
        ).catch(err => {
            console.error("Unable to start destination scanning.", err);
            warningDiv.innerText = "Cannot start camera. Use HTTPS or allow camera access.";
        });
    }

    function buildTx(){
        const dest=document.getElementById("destAddress").value.trim();
        const amount=parseInt(document.getElementById("sendAmount").value);
        if(!dest||!amount) return alert("Enter destination and amount");

        const psbt=new Psbt({network:getNetwork()});
        let inputTotal=0;
        const inputs = [];

        for(const u of utxos){
            inputs.push(u);
            inputTotal+=u.value;
            if(inputTotal > amount + 1000) break;
        }

        const estimatedFee = 250; // A simple fixed fee estimate for now
        const sendAmountPlusFee = amount + estimatedFee;

        if(inputTotal < sendAmountPlusFee){
            return alert("Insufficient balance. Need " + (sendAmountPlusFee - inputTotal) + " more sats.");
        }

        inputs.forEach(u => {
            psbt.addInput({
                hash:u.txid,
                index:u.vout,
                witnessUtxo:{
                    script:payments.p2wpkh({ address:u.address, network:getNetwork() }).output,
                    value:u.value
                }
            });
        });

        psbt.addOutput({address:dest,value:amount});
        const change=inputTotal-amount-estimatedFee;
        if(change>546) psbt.addOutput({address:derivedAddresses[0],value:change});
        document.getElementById("unsignedTx").value=psbt.toHex();
        goToSign();
    }
    async function broadcastTx(){
        const signed=document.getElementById("signedTx").value.trim();
        if(!signed) return alert("Paste signed TX");
        const statusDiv = document.getElementById("txStatus");
        statusDiv.innerText = "Broadcasting...";
        try {
            const res=await fetch(`${getApi()}/tx`,{
                method:"POST",
                headers:{"Content-Type":"text/plain"},
                body:signed
            });
            const txid=await res.text();
            statusDiv.innerText= res.ok?"✓ Broadcasted: "+txid:"✗ Error: "+txid;
            if(res.ok){
                setTimeout(() => {
                    loadWallet(); // Refresh balance
                    goToWallet();
                }, 5000);
            }
        } catch(e) {
            statusDiv.innerText = "Network Error: " + e.message;
        }
    }
    loadWallet();

    



        
</script> 
    </body>
    </html>












    


