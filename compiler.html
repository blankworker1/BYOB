<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BYOB One – Minimal Wallet</title>
    <style>
        body { font-family: sans-serif; max-width: 480px; margin: auto; padding: 20px; }
        .screen { display:none; }
        .screen.active { display:block; }
        input, button, textarea { font-size:16px; padding:8px; margin:5px 0; width:100%; box-sizing:border-box; }
        canvas { display:block; margin:10px auto; }
        .network-toggle { margin-bottom:10px; }
        #xpubScanner, #destScanner { width:100%; height:300px; display:none; border:1px solid #ccc; margin-top:10px; }
        .warning { color:red; font-size:14px; margin-top:5px; }
    </style>
</head>
<body>
    <h2>BYOB One – Minimal Wallet</h2>
    <div class="network-toggle">
        <label><input type="radio" name="network" value="mainnet"> Mainnet</label>
        <label><input type="radio" name="network" value="testnet" checked> Testnet</label>
    </div>

    <!-- WALLET SCREEN -->
    <div id="walletScreen" class="screen active">
        <div id="xpubImportSection">
            <input type="text" id="xpubInput" placeholder="Paste XPUB here">
            <button onclick="saveXpub()">Save XPUB</button>
            <button onclick="startXpubScan()">Scan XPUB QR</button>
            <div id="xpubScanner"></div>
            <div id="cameraWarning" class="warning"></div>
        </div>
        <div id="walletInfoSection" style="display:none;">
            <p><strong>Balance:</strong> <span id="balanceDisplay"></span></p>
            <p><strong>Next Receive Address:</strong></p>
            <p id="receiveAddress"></p>
            <canvas id="receiveQR" width="220" height="220"></canvas>
            <button onclick="goToSend()">Send BTC</button>
        </div>
    </div>

    <!-- SEND SCREEN -->
    <div id="sendScreen" class="screen">
        <p><strong>Destination Address:</strong></p>
        <input type="text" id="destAddress">
        <button onclick="startDestScan()">Scan Destination QR</button>
        <div id="destScanner"></div>
        <div id="destWarning" class="warning"></div>
        <p><strong>Amount (sats):</strong></p>
        <input type="number" id="sendAmount">
        <p><strong>Fee rate (sat/vbyte):</strong></p>
        <input type="range" id="feeSlider" min="1" max="200" value="10" oninput="document.getElementById('feeValue').innerText = this.value">
        <span id="feeValue">10</span> sat/vB
        <button onclick="buildTx()">Build TX</button>
        <button onclick="goToWallet()">Back</button>
    </div>

    <!-- SIGN SCREEN -->
    <div id="signScreen" class="screen">
        <p>Unsigned TX hex:</p>
        <textarea id="unsignedTx" rows="6"></textarea>
        <p>Paste signed TX hex:</p>
        <textarea id="signedTx" rows="6"></textarea>
        <button onclick="broadcastTx()">Broadcast TX</button>
        <button onclick="goToWallet()">Back</button>
        <div id="txStatus"></div>
    </div>


<script>
// --- Robust Sequential Library Loader (Fixes the race condition) ---
const libraryStatusDiv = document.getElementById('libraryStatus');
// Using the correct libraries for the functions used in the script
const scriptsToLoad = [
    { url: 'js/buffer.min.js', check: () => typeof window.Buffer !== 'undefined', name: 'Buffer' },
    { url: 'js/bip32.min.js', check: () => typeof window.bip32 !== 'undefined', name: 'BIP32' },
    { url: 'js/bitcoinjs-lib.min.js', check: () => typeof window.bitcoin !== 'undefined', name: 'BitcoinJS' },
    { url: 'js/qrcode.min.js', check: () => typeof window.QRCode !== 'undefined', name: 'QRCode' },
    { url: 'js/html5-qrcode.min.js', check: () => typeof window.Html5Qrcode !== 'undefined', name: 'Html5Qrcode' }
];

function updateStatus(msg, isError = false) {
    // You can uncomment the line below to see loading status on the page
    // if (libraryStatusDiv) { libraryStatusDiv.innerHTML = msg; }
    console.log(msg);
}

function loadScriptSequentially(index) {
    if (index >= scriptsToLoad.length) {
        updateStatus('✓ All libraries loaded successfully!');
        initApp(); // <-- CRITICAL: Only start the app AFTER all libraries are loaded
        return;
    }

    const scriptInfo = scriptsToLoad[index];
    updateStatus(`Loading \${scriptInfo.name}...`);

    const script = document.createElement('script');
    script.src = scriptInfo.url;
    script.async = false; // Important for order

    script.onload = () => {
        if (scriptInfo.check()) {
            loadScriptSequentially(index + 1);
        } else {
            updateStatus(`✗ Failed to initialize ${scriptInfo.name}. Check console.`, true);
            console.error(`Script for ${scriptInfo.name} loaded but global object not found.`);
        }
    };

    script.onerror = () => {
        updateStatus(`✗ Failed to load ${scriptInfo.name} from ${scriptInfo.url}.`, true);
    };

    document.head.appendChild(script);
}

// --- Application Logic (Moved into initApp) ---
let currentNetwork = "testnet";
let derivedAddresses = [];
let utxos = [];
let appReady = false;

function initApp() {
    console.log("Initializing app...");
    appReady = true;
    const { networks, payments, Psbt } = bitcoin; // This is now safe to do

    const walletScreen = document.getElementById("walletScreen");
    const sendScreen = document.getElementById("sendScreen");
    const signScreen = document.getElementById("signScreen");

    function showScreen(screen){
        document.querySelectorAll('.screen').forEach(s=>s.classList.remove("active"));
        screen.classList.add("active");
    }
    window.goToSend = () => showScreen(sendScreen);
    window.goToWallet = () => showScreen(walletScreen);
    window.goToSign = () => showScreen(signScreen);

    document.querySelectorAll('input[name="network"]').forEach(radio=>{
        radio.addEventListener("change",()=>{
            currentNetwork = radio.value;
            loadWallet();
        });
    });

    function getNetwork(){ return currentNetwork==="mainnet"?networks.bitcoin:networks.testnet; }
    function getApi(){ return currentNetwork==="mainnet"? "https://mempool.space/api": "https://mempool.space/testnet/api"; }
    function getStorageKey(){ return "byob_xpub_"+currentNetwork; }

    window.saveXpub = function(){
        const xpubInput = document.getElementById("xpubInput");
        const xpub = xpubInput.value.trim();
        if (!xpub) return alert("Enter XPUB");

        let xpubNetwork;

        try {
            if (xpub.startsWith("xpub")) {
                xpubNetwork = bitcoin.networks.bitcoin;
            } else if (xpub.startsWith("tpub")) {
                xpubNetwork = bitcoin.networks.testnet;
            } else {
                throw new Error("XPUB must start with 'xpub' (mainnet) or 'tpub' (testnet).");
            }

            // Validate the XPUB against its own network
            bip32.fromBase58(xpub, xpubNetwork);

            // Check for localStorage availability
            localStorage.setItem("test_xpub", xpub);
            if (localStorage.getItem("test_xpub") !== xpub) {
                throw new Error("localStorage is not available or full.");
            }
            localStorage.removeItem("test_xpub");

            // If the XPUB's network doesn't match the UI, switch the UI
            if ((xpubNetwork === bitcoin.networks.bitcoin && currentNetwork !== "mainnet") ||
                (xpubNetwork === bitcoin.networks.testnet && currentNetwork !== "testnet")) {
                
                const networkName = xpubNetwork === bitcoin.networks.bitcoin ? "mainnet" : "testnet";
                if (!confirm(`This is a ${networkName} XPUB, but you have ${currentNetwork} selected. Switch to ${networkName}?`)) {
                    return;
                }
                document.querySelector(`input[name="network"][value="${networkName}"]`).checked = true;
                currentNetwork = networkName;
            }

            localStorage.setItem(getStorageKey(), xpub);
            loadWallet();

        } catch (err) {
            console.error("XPUB Validation Error:", err);
            alert("Invalid XPUB: " + err.message);
        }
    }

    async function loadWallet(){
        const xpub=localStorage.getItem(getStorageKey());
        if(!xpub){
            document.getElementById("xpubImportSection").style.display="block";
            document.getElementById("walletInfoSection").style.display="none";
            return;
        }
        document.getElementById("xpubImportSection").style.display="none";
        document.getElementById("walletInfoSection").style.display="block";
        document.getElementById("balanceDisplay").innerText="Loading...";
        try {
            await deriveAddresses(xpub);
            await fetchBalance();
        } catch (e) {
            console.error("Failed to load wallet", e);
            document.getElementById("balanceDisplay").innerText = "Error loading wallet";
            alert("Could not load wallet. See console.");
        }
    }

    async function deriveAddresses(xpub){
        derivedAddresses=[];
        const node=bip32.fromBase58(xpub,getNetwork());
        for(let i=0;i<20;i++){
            const child=node.derive(0).derive(i);
            const {address}=payments.p2wpkh({ pubkey:child.publicKey, network:getNetwork() });
            derivedAddresses.push(address);
        }
    }

    async function fetchBalance(){
        utxos=[]; let total=0;
        for(let addr of derivedAddresses){
            try {
                const res=await fetch(`${getApi()}/address/${addr}/utxo`);
                if (!res.ok) throw new Error(`API error for ${addr}: ${res.statusText}`);
                const data=await res.json();
                data.forEach(u=>{ utxos.push({...u, address}); total+=u.value; });
            } catch (e) { console.error(`Failed to fetch balance for \${addr}:`, e); }
        }
        document.getElementById("balanceDisplay").innerText= total.toLocaleString()+" sats";
        displayReceive();
    }

    function displayReceive(){
        const addr=derivedAddresses[0];
        document.getElementById("receiveAddress").innerText=addr;
        QRCode.toCanvas( document.getElementById("receiveQR"), addr, { width:220 }, (error) => { if (error) console.error(error); });
    }

    
    window.startXpubScan = function(){
        const scannerDiv=document.getElementById("xpubScanner"); 
        const warningDiv=document.getElementById("cameraWarning");
        scannerDiv.style.display="block"; 
        warningDiv.innerText = "";
        const html5QrCode=new Html5Qrcode("xpubScanner");
        html5QrCode.start(
            { facingMode:"environment" }, 
            { fps:10, qrbox:250 }, 
            txt=>{
                html5QrCode.stop().then(() => { 
                    scannerDiv.style.display="none"; 
                    document.getElementById("xpubInput").value=txt; 
                    window.saveXpub(); 
                })
                .catch(err => { 
                    console.error("Failed to stop scanner", err); 
                    warningDiv.innerText = "Error stopping scanner."; 
                });
            }, 
            err=> { /* Silently ignore scan errors */ }
        ).catch(err => { 
            console.error("Unable to start scanning.", err); 
            warningDiv.innerText = "Cannot start camera. Use HTTPS or allow camera access."; 
        });
    }

    window.startDestScan = function(){
        const scannerDiv=document.getElementById("destScanner"); 
        const warningDiv=document.getElementById("destWarning");
        scannerDiv.style.display="block"; 
        warningDiv.innerText = "";
        const html5QrCode=new Html5Qrcode("destScanner");
        html5QrCode.start(
            { facingMode:"environment" }, 
            { fps:10, qrbox:250 }, 
            txt=>{
                html5QrCode.stop().then(() => { 
                    scannerDiv.style.display="none"; 
                    document.getElementById("destAddress").value=txt; 
                })
                .catch(err => { 
                    console.error("Failed to stop destination scanner", err); 
                    warningDiv.innerText = "Error stopping scanner."; 
                });
            }, 
            err=> { /* Silently ignore scan errors */ }
        ).catch(err => { 
            console.error("Unable to start destination scanning.", err); 
            warningDiv.innerText = "Cannot start camera. Use HTTPS or allow camera access."; 
        });
    }

    window.buildTx = function(){
        const dest=document.getElementById("destAddress").value.trim();
        const amount=parseInt(document.getElementById("sendAmount").value);
        if(!dest||!amount) return alert("Enter destination and amount");

        const psbt=new Psbt({network:getNetwork()});
        let inputTotal=0;
        const inputs = [];

        for(const u of utxos){
            inputs.push(u);
            inputTotal+=u.value;
            if(inputTotal > amount + 1000) break;
        }

        const estimatedFee = 250;
        const sendAmountPlusFee = amount + estimatedFee;

        if(inputTotal < sendAmountPlusFee){
            return alert("Insufficient balance. Need " + (sendAmountPlusFee - inputTotal) + " more sats.");
        }

        inputs.forEach(u => {
            psbt.addInput({
                hash:u.txid,
                index:u.vout,
                witnessUtxo:{
                    script:payments.p2wpkh({ address:u.address, network:getNetwork() }).output,
                    value:u.value
                }
            });
        });

        psbt.addOutput({address:dest,value:amount});
        const change=inputTotal-amount-estimatedFee;
        if(change>546) psbt.addOutput({address:derivedAddresses[0],value:change});

        document.getElementById("unsignedTx").value=psbt.toHex();
        goToSign();
    }
    window.broadcastTx = async function(){
        const signed=document.getElementById("signedTx").value.trim();
        if(!signed) return alert("Paste signed TX");
        const statusDiv = document.getElementById("txStatus");
        statusDiv.innerText = "Broadcasting...";
        try {
            const res=await fetch(`${getApi()}/tx`,{
                method:"POST",
                headers:{"Content-Type":"text/plain"},
                body:signed
            });
            const txid=await res.text();
            statusDiv.innerText= res.ok?"✓ Broadcasted: "+txid:"✗ Error: "+txid;
            if(res.ok){
                setTimeout(() => { loadWallet(); goToWallet(); }, 5000);
            }
        } catch(e) {
            statusDiv.innerText = "Network Error: " + e.message;
        }
    }
    loadWallet();
}



        
</script> 
    </body>
    </html>












    


