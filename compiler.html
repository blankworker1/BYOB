<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BYOB One – Wallet</title>
<style>
body { font-family: sans-serif; max-width: 480px; margin: auto; padding: 20px; }
.screen { display:none; }
.screen.active { display:block; }
input, button, textarea { font-size:16px; padding:8px; margin:5px 0; width:100%; box-sizing:border-box; }
.network-toggle { margin-bottom:10px; }
.warning { color:red; font-size:14px; margin-top:5px; }
#loadingStatus { background:#fff3cd; padding:15px; margin:10px 0; border:2px solid #ffc107; font-size:14px; line-height:1.6; }
.success { background:#d4edda; border-color:#28a745; }
.error { background:#ffcccc; border-color:#cc0000; }
</style>
</head>
<body>

<h2>BYOB One – Wallet</h2>

<div id="loadingStatus">⏳ Loading libraries...</div>

<div id="mainApp" style="display:none;">
    <div class="network-toggle">
        <label><input type="radio" name="network" value="mainnet"> Mainnet</label>
        <label><input type="radio" name="network" value="testnet" checked> Testnet</label>
    </div>

    <div id="walletScreen" class="screen active">
        <div id="xpubImportSection">
            <input type="text" id="xpubInput" placeholder="Paste XPUB here">
            <button onclick="saveXpub()">Save XPUB</button>
        </div>
        <div id="walletInfoSection" style="display:none;">
            <p><strong>Balance:</strong> <span id="balanceDisplay"></span></p>
            <p><strong>Next Receive Address:</strong></p>
            <p id="receiveAddress" style="word-break:break-all; font-size:12px;"></p>
            <div id="qrCode"></div>
            <button onclick="goToSend()">Send BTC</button>
        </div>
    </div>

    <div id="sendScreen" class="screen">
        <p><strong>Destination Address:</strong></p>
        <input type="text" id="destAddress">
        <p><strong>Amount (sats):</strong></p>
        <input type="number" id="sendAmount">
        <p><strong>Fee rate (sat/vbyte):</strong></p>
        <input type="range" id="feeSlider" min="1" max="200" value="10" oninput="document.getElementById('feeValue').innerText = this.value">
        <span id="feeValue">10</span> sat/vB
        <button onclick="buildTx()">Build TX</button>
        <button onclick="goToWallet()">Back</button>
    </div>

    <div id="signScreen" class="screen">
        <p>Unsigned TX hex:</p>
        <textarea id="unsignedTx" rows="6"></textarea>
        <p>Paste signed TX hex:</p>
        <textarea id="signedTx" rows="6"></textarea>
        <button onclick="broadcastTx()">Broadcast TX</button>
        <button onclick="goToWallet()">Back</button>
        <div id="txStatus"></div>
    </div>
</div>

<!-- ------------- Library Scripts (UMD, browser-friendly) ------------- -->
<script src="https://cdn.jsdelivr.net/npm/tiny-secp256k1@2.2.3/dist/tiny-secp256k1.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@safeheron/crypto-bip32@2.0.0/dist/index.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bitcoinjs-lib-browser@5.1.7/bitcoinjs.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>

<script>
  // Force globals for wallet code
  window.bip32 = window.bip32 || bip32.default || bip32;
  window.bitcoin = window.bitcoin || bitcoin;
  window.tinysecp256k1 = window.tinysecp256k1 || tinysecp256k1;

  const loadingStatus = document.getElementById("loadingStatus");
  if(!window.bip32 || !window.bitcoin || !window.tinysecp256k1 || !window.qrcode) {
      loadingStatus.innerHTML = "❌ Failed to load libraries. Please check your connection.";
      loadingStatus.className = "error";
  } else {
      loadingStatus.innerHTML = "✅ Libraries loaded successfully!";
      loadingStatus.className = "success";
      setTimeout(() => {
          loadingStatus.style.display = "none";
          document.getElementById("mainApp").style.display = "block";
          initApp();
      }, 800);
  }
</script>

<script>
let currentNetwork = "testnet";
let derivedAddresses = [];
let utxos = [];

function initApp() {
    window.goToSend = () => showScreen('sendScreen');
    window.goToWallet = () => showScreen('walletScreen');
    window.goToSign = () => showScreen('signScreen');

    function showScreen(screenId) {
        document.querySelectorAll('.screen').forEach(s => s.classList.remove("active"));
        document.getElementById(screenId).classList.add("active");
    }

    document.querySelectorAll('input[name="network"]').forEach(radio => {
        radio.addEventListener("change", () => {
            currentNetwork = radio.value;
            loadWallet();
        });
    });

    function getNetwork() { 
        return currentNetwork === "mainnet" ? bitcoin.networks.bitcoin : bitcoin.networks.testnet; 
    }
    
    function getApi() { 
        return currentNetwork === "mainnet" ? "https://mempool.space/api" : "https://mempool.space/testnet/api"; 
    }
    
    function getStorageKey() { 
        return "byob_xpub_" + currentNetwork; 
    }

    window.saveXpub = function () {
        try {
            const xpubInput = document.getElementById("xpubInput");
            const xpub = xpubInput.value.trim();
            
            if (!xpub) return alert("Enter XPUB");

            let xpubNetwork;
            if (xpub.startsWith("xpub")) {
                xpubNetwork = bitcoin.networks.bitcoin;
            } else if (xpub.startsWith("tpub")) {
                xpubNetwork = bitcoin.networks.testnet;
            } else {
                return alert("XPUB must start with 'xpub' (mainnet) or 'tpub' (testnet).");
            }
            
            bip32.fromBase58(xpub, xpubNetwork);
            
            if ((xpubNetwork === bitcoin.networks.bitcoin && currentNetwork !== "mainnet") ||
                (xpubNetwork === bitcoin.networks.testnet && currentNetwork !== "testnet")) {
                const networkName = xpubNetwork === bitcoin.networks.bitcoin ? "mainnet" : "testnet";
                if (!confirm(`This is a ${networkName} XPUB, but you have ${currentNetwork} selected. Switch to ${networkName}?`)) {
                    return;
                }
                document.querySelector(`input[name="network"][value="${networkName}"]`).checked = true;
                currentNetwork = networkName;
            }
            
            localStorage.setItem(getStorageKey(), xpub);
            loadWallet();
        } catch (err) {
            alert("Invalid XPUB: " + err.message);
        }
    }

    async function loadWallet() {
        const xpub = localStorage.getItem(getStorageKey());
        
        if (!xpub) {
            document.getElementById("xpubImportSection").style.display = "block";
            document.getElementById("walletInfoSection").style.display = "none";
            return;
        }
        
        document.getElementById("xpubImportSection").style.display = "none";
        document.getElementById("walletInfoSection").style.display = "block";
        document.getElementById("balanceDisplay").innerText = "Loading...";
        
        try {
            await deriveAddresses(xpub);
            await fetchBalance();
        } catch (e) {
            document.getElementById("balanceDisplay").innerText = "Error: " + e.message;
            alert("Could not load wallet: " + e.message);
        }
    }

    async function deriveAddresses(xpub) {
        derivedAddresses = [];
        const node = bip32.fromBase58(xpub, getNetwork());
        
        for (let i = 0; i < 20; i++) {
            const child = node.derive(0).derive(i);
            const { address } = bitcoin.payments.p2wpkh({ 
                pubkey: child.publicKey, 
                network: getNetwork() 
            });
            derivedAddresses.push(address);
        }
    }

    async function fetchBalance() {
        utxos = [];
        let total = 0;
        const api = getApi();
        
        for (let addr of derivedAddresses) {
            try {
                const res = await fetch(`${api}/address/${addr}/utxo`);
                if (!res.ok) continue;
                const data = await res.json();
                
                data.forEach(u => {
                    utxos.push({ ...u, address: addr });
                    total += u.value;
                });
            } catch (e) {
                console.error(`Failed to fetch ${addr}:`, e);
            }
        }
        
        document.getElementById("balanceDisplay").innerText = total.toLocaleString() + " sats";
        displayReceive();
    }

    function displayReceive() {
        const addr = derivedAddresses[0];
        document.getElementById("receiveAddress").innerText = addr;
        
        const qr = qrcode(0, 'M');
        qr.addData(addr);
        qr.make();
        document.getElementById("qrCode").innerHTML = qr.createImgTag(4);
    }

    window.buildTx = function () {
        try {
            const dest = document.getElementById("destAddress").value.trim();
            const amount = parseInt(document.getElementById("sendAmount").value);
            
            if (!dest || !amount) return alert("Enter destination and amount");

            const psbt = new bitcoin.Psbt({ network: getNetwork() });
            let inputTotal = 0;
            const inputs = [];

            for (const u of utxos) {
                inputs.push(u);
                inputTotal += u.value;
                if (inputTotal > amount + 1000) break;
            }

            const estimatedFee = 250;
            const sendAmountPlusFee = amount + estimatedFee;

            if (inputTotal < sendAmountPlusFee) {
                return alert("Insufficient balance. Need " + (sendAmountPlusFee - inputTotal) + " more sats.");
            }

            inputs.forEach(u => {
                psbt.addInput({
                    hash: u.txid,
                    index: u.vout,
                    witnessUtxo: {
                        script: bitcoin.payments.p2wpkh({ 
                            address: u.address, 
                            network: getNetwork() 
                        }).output,
                        value: u.value
                    }
                });
            });

            psbt.addOutput({ address: dest, value: amount });
            const change = inputTotal - amount - estimatedFee;
            if (change > 546) {
                psbt.addOutput({ address: derivedAddresses[0], value: change });
            }

            document.getElementById("unsignedTx").value = psbt.toHex();
            goToSign();
        } catch(e) {
            alert('Error building transaction: ' + e.message);
        }
    }

    window.broadcastTx = async function () {
        try {
            const signed = document.getElementById("signedTx").value.trim();
            if (!signed) return alert("Paste signed TX");
            
            const statusDiv = document.getElementById("txStatus");
            statusDiv.innerText = "Broadcasting...";
            
            const res = await fetch(`${getApi()}/tx`, {
                method: "POST",
                headers: { "Content-Type": "text/plain" },
                body: signed
            });
            
            const txid = await res.text();
            statusDiv.innerText = res.ok ? "✓ Broadcasted: " + txid : "✗ Error: " + txid;
            
            if (res.ok) {
                setTimeout(() => { 
                    loadWallet(); 
                    goToWallet(); 
                }, 5000);
            }
        } catch (e) {
            document.getElementById("txStatus").innerText = "Network Error: " + e.message;
        }
    }

    loadWallet();
}
</script>

</body>
</html>
