<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BYOB One – Minimal Wallet</title>
    <style>
        body { font-family: sans-serif; max-width: 480px; margin: auto; padding: 20px; }
        .screen { display:none; }
        .screen.active { display:block; }
        input, button, textarea { font-size:16px; padding:8px; margin:5px 0; width:100%; box-sizing:border-box; }
        canvas { display:block; margin:10px auto; }
        .network-toggle { margin-bottom:10px; }
        #xpubScanner, #destScanner { width:100%; height:300px; display:none; border:1px solid #ccc; margin-top:10px; }
        .warning { color:red; font-size:14px; margin-top:5px; }
    </style>
</head>
<body>
    <h2>BYOB One – Minimal Wallet</h2>
    <div class="network-toggle">
        <label><input type="radio" name="network" value="mainnet"> Mainnet</label>
        <label><input type="radio" name="network" value="testnet" checked> Testnet</label>
    </div>

    <!-- WALLET SCREEN -->
    <div id="walletScreen" class="screen active">
        <div id="xpubImportSection">
            <input type="text" id="xpubInput" placeholder="Paste XPUB here">
            <button onclick="saveXpub()">Save XPUB</button>
            <button onclick="startXpubScan()">Scan XPUB QR</button>
            <div id="xpubScanner"></div>
            <div id="cameraWarning" class="warning"></div>
        </div>
        <div id="walletInfoSection" style="display:none;">
            <p><strong>Balance:</strong> <span id="balanceDisplay"></span></p>
            <p><strong>Next Receive Address:</strong></p>
            <p id="receiveAddress"></p>
            <canvas id="receiveQR" width="220" height="220"></canvas>
            <button onclick="goToSend()">Send BTC</button>
        </div>
    </div>

    <!-- SEND SCREEN -->
    <div id="sendScreen" class="screen">
        <p><strong>Destination Address:</strong></p>
        <input type="text" id="destAddress">
        <button onclick="startDestScan()">Scan Destination QR</button>
        <div id="destScanner"></div>
        <div id="destWarning" class="warning"></div>
        <p><strong>Amount (sats):</strong></p>
        <input type="number" id="sendAmount">
        <p><strong>Fee rate (sat/vbyte):</strong></p>
        <input type="range" id="feeSlider" min="1" max="200" value="10" oninput="document.getElementById('feeValue').innerText = this.value">
        <span id="feeValue">10</span> sat/vB
        <button onclick="buildTx()">Build TX</button>
        <button onclick="goToWallet()">Back</button>
    </div>

    <!-- SIGN SCREEN -->
    <div id="signScreen" class="screen">
        <p>Unsigned TX hex:</p>
        <textarea id="unsignedTx" rows="6"></textarea>
        <p>Paste signed TX hex:</p>
        <textarea id="signedTx" rows="6"></textarea>
        <button onclick="broadcastTx()">Broadcast TX</button>
        <button onclick="goToWallet()">Back</button>
        <div id="txStatus"></div>
    </div>

    <!-- LIBRARIES (CDN - RELIABLE LOADING) -->
    <!-- NOTE: These will work if you have an internet connection. No local files needed. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es6-promise/4.2.8/es6-promise.auto.min.js"></script>
    <script src="https://bundle.run/buffer@6.0.3"></script>
    <script> window.Buffer = window.buffer.Buffer; </script>
    <script src="https://bundle.run/bip32@2.1.0"></script>
    <script src="https://bundle.run/bitcoinjs-lib@5.2.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>

    <script>
        // --- Application Logic ---
        let currentNetwork = "testnet";
        let derivedAddresses = [];
        let utxos = [];

        // Expose functions to global scope for onclick handlers
        window.goToSend = () => showScreen('sendScreen');
        window.goToWallet = () => showScreen('walletScreen');
        window.goToSign = () => showScreen('signScreen');

        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove("active"));
            document.getElementById(screenId).classList.add("active");
        }

        document.querySelectorAll('input[name="network"]').forEach(radio => {
            radio.addEventListener("change", () => {
                currentNetwork = radio.value;
                loadWallet();
            });
        });

        function getNetwork() { return currentNetwork === "mainnet" ? bitcoin.networks.bitcoin : bitcoin.networks.testnet; }
        function getApi() { return currentNetwork === "mainnet" ? "https://mempool.space/api" : "https://mempool.space/testnet/api"; }
        function getStorageKey() { return "byob_xpub_" + currentNetwork; }

        window.saveXpub = function () {
            const xpubInput = document.getElementById("xpubInput");
            const xpub = xpubInput.value.trim();
            if (!xpub) return alert("Enter XPUB");

            let xpubNetwork;
            try {
                if (xpub.startsWith("xpub")) {
                    xpubNetwork = bitcoin.networks.bitcoin;
                } else if (xpub.startsWith("tpub")) {
                    xpubNetwork = bitcoin.networks.testnet;
                } else {
                    throw new Error("XPUB must start with 'xpub' (mainnet) or 'tpub' (testnet).");
                }
                bip32.fromBase58(xpub, xpubNetwork);
                localStorage.setItem("test_xpub", xpub);
                if (localStorage.getItem("test_xpub") !== xpub) {
                    throw new Error("localStorage is not available or full.");
                }
                localStorage.removeItem("test_xpub");

                if ((xpubNetwork === bitcoin.networks.bitcoin && currentNetwork !== "mainnet") ||
                    (xpubNetwork === bitcoin.networks.testnet && currentNetwork !== "testnet")) {
                    const networkName = xpubNetwork === bitcoin.networks.bitcoin ? "mainnet" : "testnet";
                    if (!confirm(`This is a ${networkName} XPUB, but you have ${currentNetwork} selected. Switch to ${networkName}?`)) {
                        return;
                    }
                    document.querySelector(`input[name="network"][value="${networkName}"]`).checked = true;
                    currentNetwork = networkName;
                }
                localStorage.setItem(getStorageKey(), xpub);
                loadWallet();
            } catch (err) {
                console.error("XPUB Validation Error:", err);
                alert("Invalid XPUB: " + err.message);
            }
        }

        async function loadWallet() {
            const xpub = localStorage.getItem(getStorageKey());
            if (!xpub) {
                document.getElementById("xpubImportSection").style.display = "block";
                document.getElementById("walletInfoSection").style.display = "none";
                return;
            }
            document.getElementById("xpubImportSection").style.display = "none";
            document.getElementById("walletInfoSection").style.display = "block";
            document.getElementById("balanceDisplay").innerText = "Loading...";
            try {
                await deriveAddresses(xpub);
                await fetchBalance();
            } catch (e) {
                console.error("Failed to load wallet", e);
                document.getElementById("balanceDisplay").innerText = "Error loading wallet";
                alert("Could not load wallet. See console.");
            }
        }

        async function deriveAddresses(xpub) {
            derivedAddresses = [];
            const node = bip32.fromBase58(xpub, getNetwork());
            for (let i = 0; i < 20; i++) {
                const child = node.derive(0).derive(i);
                const { address } = bitcoin.payments.p2wpkh({ pubkey: child.publicKey, network: getNetwork() });
                derivedAddresses.push(address);
            }
        }

        async function fetchBalance() {
            utxos = [];
            let total = 0;
            for (let addr of derivedAddresses) {
                try {
                    const res = await fetch(`${getApi()}/address/${addr}/utxo`);
                    if (!res.ok) throw new Error(`API error for ${addr}: ${res.statusText}`);
                    const data = await res.json();
                    data.forEach(u => {
                        utxos.push({ ...u, address });
                        total += u.value;
                    });
                } catch (e) {
                    console.error(`Failed to fetch balance for ${addr}:`, e);
                }
            }
            document.getElementById("balanceDisplay").innerText = total.toLocaleString() + " sats";
            displayReceive();
        }

        function displayReceive() {
            const addr = derivedAddresses[0];
            document.getElementById("receiveAddress").innerText = addr;
            QRCode.toCanvas(document.getElementById("receiveQR"), addr, { width: 220 }, (error) => {
                if (error) console.error(error);
            });
        }

        window.startXpubScan = function () {
            const scannerDiv = document.getElementById("xpubScanner");
            const warningDiv = document.getElementById("cameraWarning");
            scannerDiv.style.display = "block";
            warningDiv.innerText = "";
            const html5QrCode = new Html5Qrcode("xpubScanner");
            html5QrCode.start(
                { facingMode: "environment" },
                { fps: 10, qrbox: 250 },
                txt => {
                    html5QrCode.stop().then(() => {
                        scannerDiv.style.display = "none";
                        document.getElementById("xpubInput").value = txt;
                        window.saveXpub();
                    })
                        .catch(err => {
                            console.error("Failed to stop scanner", err);
                            warningDiv.innerText = "Error stopping scanner.";
                        });
                },
                err => { /* Silently ignore scan errors */ }
            ).catch(err => {
                console.error("Unable to start scanning.", err);
                warningDiv.innerText = "Cannot start camera. Use HTTPS or allow camera access.";
            });
        }

        window.startDestScan = function () {
            const scannerDiv = document.getElementById("destScanner");
            const warningDiv = document.getElementById("destWarning");
            scannerDiv.style.display = "block";
            warningDiv.innerText = "";
            const html5QrCode = new Html5Qrcode("destScanner");
            html5QrCode.start(
                { facingMode: "environment" },
                { fps: 10, qrbox: 250 },
                txt => {
                    html5QrCode.stop().then(() => {
                        scannerDiv.style.display = "none";
                        document.getElementById("destAddress").value = txt;
                    })
                        .catch(err => {
                            console.error("Failed to stop destination scanner", err);
                            warningDiv.innerText = "Error stopping scanner.";
                        });
                },
                err => { /* Silently ignore scan errors */ }
            ).catch(err => {
                console.error("Unable to start destination scanning.", err);
                warningDiv.innerText = "Cannot start camera. Use HTTPS or allow camera access.";
            });
        }

        window.buildTx = function () {
            const dest = document.getElementById("destAddress").value.trim();
            const amount = parseInt(document.getElementById("sendAmount").value);
            if (!dest || !amount) return alert("Enter destination and amount");

            const psbt = new bitcoin.Psbt({ network: getNetwork() });
            let inputTotal = 0;
            const inputs = [];

            for (const u of utxos) {
                inputs.push(u);
                inputTotal += u.value;
                if (inputTotal > amount + 1000) break;
            }

            const estimatedFee = 250;
            const sendAmountPlusFee = amount + estimatedFee;

            if (inputTotal < sendAmountPlusFee) {
                return alert("Insufficient balance. Need " + (sendAmountPlusFee - inputTotal) + " more sats.");
            }

            inputs.forEach(u => {
                psbt.addInput({
                    hash: u.txid,
                    index: u.vout,
                    witnessUtxo: {
                        script: bitcoin.payments.p2wpkh({ address: u.address, network: getNetwork() }).output,
                        value: u.value
                    }
                });
            });

            psbt.addOutput({ address: dest, value: amount });
            const change = inputTotal - amount - estimatedFee;
            if (change > 546) psbt.addOutput({ address: derivedAddresses[0], value: change });

            document.getElementById("unsignedTx").value = psbt.toHex();
            goToSign();
        }

        window.broadcastTx = async function () {
            const signed = document.getElementById("signedTx").value.trim();
            if (!signed) return alert("Paste signed TX");
            const statusDiv = document.getElementById("txStatus");
            statusDiv.innerText = "Broadcasting...";
            try {
                const res = await fetch(`${getApi()}/tx`, {
                    method: "POST",
                    headers: { "Content-Type": "text/plain" },
                    body: signed
                });
                const txid = await res.text();
                statusDiv.innerText = res.ok ? "✓ Broadcasted: " + txid : "✗ Error: " + txid;
                if (res.ok) {
                    setTimeout(() => { loadWallet(); goToWallet(); }, 5000);
                }
            } catch (e) {
                statusDiv.innerText = "Network Error: " + e.message;
            }
        }

        // Initial load
        loadWallet();
    </script>
</body>
</html>






            
            
