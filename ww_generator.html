<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BYOB WW_GENERATOR</title>
<style>
body {
  font-family: sans-serif;
  padding: 20px;
}
input { margin-bottom: 10px; }
button { margin: 5px; }
</style>
</head>
<body>

<h2>BIP39 WORDWALL Poster Generator</h2>

<label>Community Label (4 chars): 
<input type="text" id="nameInput" placeholder="BOSA" maxlength="4">
</label><br>

<button onclick="generateSeed()">Generate Canonical Wall</button>

<div id="seedDisplay"></div>
<button id="copyButton" onclick="copySeed()" style="display:none;">Copy Seed</button>
<button id="downloadButton" onclick="downloadPosters()" style="display:none;">
Download Posters + Canonical JSON
</button>

<script src="bip39_words.js"></script>

<script>

const rowLetters = ["A","B","C","D","E","F","G","J","K","L","M","N","O","P","R","S","T","V","X","Y","Z"];
let currentSeed = "";

// ---------------- SEED ----------------

function generateSeed() {
  const name = document.getElementById("nameInput").value.toUpperCase() || "BOSA";
  currentSeed = `BYOB_CANONICAL_${name}`;

  document.getElementById("seedDisplay").textContent = "Canonical Seed: " + currentSeed;
  document.getElementById("copyButton").style.display = "inline";
  document.getElementById("downloadButton").style.display = "inline";
}

function copySeed() {
  navigator.clipboard.writeText(currentSeed);
  alert("Seed copied.");
}

// ---------------- HASH + RNG ----------------

async function hashSeed(seed) {
  const encoder = new TextEncoder();
  const data = encoder.encode(seed);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  return new Uint32Array(hashBuffer);
}

function mulberry32(a) {
  return function() {
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
}

function shuffle(array, rng) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

// ---------------- EXPORT JSON ----------------

function downloadCanonicalJSON(mapping, community, seedHashHex) {
  const exportData = {
    meta: {
      community: community,
      seed_hash: seedHashHex,
      version: "1"
    },
    mapping: mapping
  };

  const blob = new Blob(
    [JSON.stringify(exportData, null, 2)],
    { type: "application/json" }
  );

  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = `${community}_canonical_wall.json`;
  link.click();
}

// ---------------- POSTER + JSON ----------------

async function downloadPosters() {

  if(typeof bip39Words === "undefined" || bip39Words.length !== 2048){
    alert("BIP39 word list not loaded correctly!");
    return;
  }

  const totalRows = 21;
  const sheetCols = 20;
  const sheets = 5;
  const headerColor = "#cccccc";
  const circledNumbers = ["①","②","③","④","⑤"];

  const dpi = 300;
  const width_mm = 841, height_mm = 594;
  const width_px = Math.floor(width_mm / 25.4 * dpi);
  const height_px = Math.floor(height_mm / 25.4 * dpi);

  const hashArray = await hashSeed(currentSeed);
  const rng = mulberry32(hashArray[0]);
  const wordsCopy = bip39Words.slice();
  shuffle(wordsCopy, rng);

  const wallID = document.getElementById("nameInput").value.toUpperCase() || "BOSA";

  let wordIndex = 0;
  const canonicalMapping = {};

  function isCellAllowed(globalCol, row, sheetIndex) {
    if (row === totalRows - 1 && globalCol === (sheetIndex + 1) * sheetCols) {
      return false;
    }
    if (sheetIndex === 4) {
      if (globalCol === 100) return false;
      if (globalCol === 99) return false;
      if (globalCol === 98 && row >= totalRows - 6) return false;
    }
    return true;
  }

  for(let s=0; s<sheets; s++){

    const colStart = s * sheetCols;

    const canvas = document.createElement("canvas");
    canvas.width = width_px;
    canvas.height = height_px;
    const ctx = canvas.getContext("2d");

    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    const totalGridCols = sheetCols + 1;
    const totalGridRows = totalRows + 1;

    const cellWidth = canvas.width / totalGridCols;
    const cellHeight = canvas.height / totalGridRows;

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // Page number
    ctx.fillStyle = headerColor;
    ctx.fillRect(0,0,cellWidth,cellHeight);
    ctx.font = `${Math.floor(cellHeight*0.5)}px sans-serif`;
    ctx.fillStyle = "#000";
    ctx.fillText(circledNumbers[s], cellWidth/2, cellHeight/2);
    ctx.strokeRect(0,0,cellWidth,cellHeight);

    // Column headers
    for(let c=0;c<sheetCols;c++){
      const x = cellWidth + c*cellWidth;
      ctx.fillStyle = headerColor;
      ctx.fillRect(x,0,cellWidth,cellHeight);
      const colNumber = String(colStart+c+1).padStart(2,"0");
      ctx.font = `${Math.floor(cellHeight*0.3)}px sans-serif`;
      ctx.fillStyle = "#000";
      ctx.fillText(colNumber, x+cellWidth/2, cellHeight/2);
      ctx.strokeRect(x,0,cellWidth,cellHeight);
    }

    for(let r=0;r<totalRows;r++){

      const y = cellHeight + r*cellHeight;

      // Row header
      ctx.fillStyle = headerColor;
      ctx.fillRect(0,y,cellWidth,cellHeight);
      ctx.font = `${Math.floor(cellHeight*0.3)}px sans-serif`;
      ctx.fillStyle = "#000";
      ctx.fillText(rowLetters[r], cellWidth/2, y+cellHeight/2);
      ctx.strokeRect(0,y,cellWidth,cellHeight);

      for(let c=0;c<sheetCols;c++){

        const x = cellWidth + c*cellWidth;
        const globalCol = colStart + c + 1;
        const allowed = isCellAllowed(globalCol, r, s);

        let word = "";
        let fontSize = Math.floor(cellHeight*0.5);

        const isBottomRight =
          (r === totalRows - 1) &&
          (globalCol === (s + 1) * sheetCols);

        ctx.fillStyle = allowed ? "#ffffff" : headerColor;
        ctx.fillRect(x,y,cellWidth,cellHeight);

        if(isBottomRight){
          ctx.font = `${fontSize}px sans-serif`;
          ctx.fillStyle = "#000";
          ctx.fillText(wallID, x+cellWidth/2, y+cellHeight/2);
        }
        else if(allowed && wordIndex < wordsCopy.length){

          const fullWord = wordsCopy[wordIndex];

          const sheetNum = String(s+1).padStart(2,"0");
          const rowNum = String(r+1).padStart(2,"0");
          const colNum = String(c+1).padStart(2,"0");
          const coord = sheetNum + rowNum + colNum;

          canonicalMapping[fullWord] = coord;

          word = fullWord.slice(0,4);
          ctx.font = `${fontSize}px sans-serif`;
          ctx.fillStyle = "#000";
          ctx.fillText(word, x+cellWidth/2, y+cellHeight/2);

          wordIndex++;
        }

        ctx.strokeRect(x,y,cellWidth,cellHeight);
      }
    }

    canvas.toBlob(function(blob){
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = `${wallID}_Sheet${s+1}.png`;
      link.click();
    }, "image/png");
  }

  const seedHashHex = Array.from(hashArray)
    .map(x => x.toString(16).padStart(8,"0"))
    .join("");

  downloadCanonicalJSON(canonicalMapping, wallID, seedHashHex);
}

</script>
</body>  
</html>









