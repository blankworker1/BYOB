var scureBip32=(()=>{var Je=Object.defineProperty;var qr=Object.getOwnPropertyDescriptor;var kr=Object.getOwnPropertyNames;var Vr=Object.prototype.hasOwnProperty;var Mr=(t,e)=>{for(var n in e)Je(t,n,{get:e[n],enumerable:!0})},Zr=(t,e,n,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of kr(e))!Vr.call(t,o)&&o!==n&&Je(t,o,{get:()=>e[o],enumerable:!(r=qr(e,o))||r.enumerable});return t};var $r=t=>Zr(Je({},"__esModule",{value:!0}),t);var On={};Mr(On,{HDKey:()=>Qe});function Re(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function ee(t,e=""){if(!Number.isSafeInteger(t)||t<0){let n=e&&`"${e}" `;throw new Error(`${n}expected integer >= 0, got ${t}`)}}function O(t,e,n=""){let r=Re(t),o=t?.length,s=e!==void 0;if(!r||s&&o!==e){let i=n&&`"${n}" `,c=s?` of length ${e}`:"",f=r?`length=${o}`:`type=${typeof t}`;throw new Error(i+"expected Uint8Array"+c+", got "+f)}return t}function Ve(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash must wrapped by utils.createHasher");ee(t.outputLen),ee(t.blockLen)}function me(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function Vt(t,e){O(t,void 0,"digestInto() output");let n=e.outputLen;if(t.length<n)throw new Error('"digestInto() output" expected to be of length >='+n)}function X(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}function ie(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function Q(t,e){return t<<32-e|t>>>e}function He(t,e){return t<<e|t>>>32-e>>>0}var Mt=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",jr=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function le(t){if(O(t),Mt)return t.toHex();let e="";for(let n=0;n<t.length;n++)e+=jr[t[n]];return e}var ne={_0:48,_9:57,A:65,F:70,a:97,f:102};function kt(t){if(t>=ne._0&&t<=ne._9)return t-ne._0;if(t>=ne.A&&t<=ne.F)return t-(ne.A-10);if(t>=ne.a&&t<=ne.f)return t-(ne.a-10)}function he(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(Mt)return Uint8Array.fromHex(t);let e=t.length,n=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);let r=new Uint8Array(n);for(let o=0,s=0;o<n;o++,s+=2){let i=kt(t.charCodeAt(s)),c=kt(t.charCodeAt(s+1));if(i===void 0||c===void 0){let f=t[s]+t[s+1];throw new Error('hex string expected, got non-hex character "'+f+'" at index '+s)}r[o]=i*16+c}return r}function j(...t){let e=0;for(let r=0;r<t.length;r++){let o=t[r];O(o),e+=o.length}let n=new Uint8Array(e);for(let r=0,o=0;r<t.length;r++){let s=t[r];n.set(s,o),o+=s.length}return n}function Ie(t,e={}){let n=(o,s)=>t(s).update(o).digest(),r=t(void 0);return n.outputLen=r.outputLen,n.blockLen=r.blockLen,n.create=o=>t(o),Object.assign(n,e),Object.freeze(n)}function Me(t=32){let e=typeof globalThis=="object"?globalThis.crypto:null;if(typeof e?.getRandomValues!="function")throw new Error("crypto.getRandomValues must be defined");return e.getRandomValues(new Uint8Array(t))}var Fe=t=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,t])});function et(t,e,n){return t&e^~t&n}function tt(t,e,n){return t&e^t&n^e&n}var be=class{blockLen;outputLen;padOffset;isLE;buffer;view;finished=!1;length=0;pos=0;destroyed=!1;constructor(e,n,r,o){this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=o,this.buffer=new Uint8Array(e),this.view=ie(this.buffer)}update(e){me(this),O(e);let{view:n,buffer:r,blockLen:o}=this,s=e.length;for(let i=0;i<s;){let c=Math.min(o-this.pos,s-i);if(c===o){let f=ie(e);for(;o<=s-i;i+=o)this.process(f,i);continue}r.set(e.subarray(i,i+c),this.pos),this.pos+=c,i+=c,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){me(this),Vt(e,this),this.finished=!0;let{buffer:n,view:r,blockLen:o,isLE:s}=this,{pos:i}=this;n[i++]=128,X(this.buffer.subarray(i)),this.padOffset>o-i&&(this.process(r,0),i=0);for(let u=i;u<o;u++)n[u]=0;r.setBigUint64(o-8,BigInt(this.length*8),s),this.process(r,0);let c=ie(e),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen must be aligned to 32bit");let a=f/4,x=this.get();if(a>x.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<a;u++)c.setUint32(4*u,x[u],s)}digest(){let{buffer:e,outputLen:n}=this;this.digestInto(e);let r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||=new this.constructor,e.set(...this.get());let{blockLen:n,buffer:r,length:o,finished:s,destroyed:i,pos:c}=this;return e.destroyed=i,e.finished=s,e.length=o,e.pos=c,o%n&&e.buffer.set(r),e}clone(){return this._cloneInto()}},oe=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]);var M=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]);var Ze=BigInt(4294967295),Zt=BigInt(32);function Gr(t,e=!1){return e?{h:Number(t&Ze),l:Number(t>>Zt&Ze)}:{h:Number(t>>Zt&Ze)|0,l:Number(t&Ze)|0}}function $t(t,e=!1){let n=t.length,r=new Uint32Array(n),o=new Uint32Array(n);for(let s=0;s<n;s++){let{h:i,l:c}=Gr(t[s],e);[r[s],o[s]]=[i,c]}return[r,o]}var rt=(t,e,n)=>t>>>n,nt=(t,e,n)=>t<<32-n|e>>>n,xe=(t,e,n)=>t>>>n|e<<32-n,pe=(t,e,n)=>t<<32-n|e>>>n,_e=(t,e,n)=>t<<64-n|e>>>n-32,Oe=(t,e,n)=>t>>>n-32|e<<64-n;function te(t,e,n,r){let o=(e>>>0)+(r>>>0);return{h:t+n+(o/2**32|0)|0,l:o|0}}var jt=(t,e,n)=>(t>>>0)+(e>>>0)+(n>>>0),Gt=(t,e,n,r)=>e+n+r+(t/2**32|0)|0,Yt=(t,e,n,r)=>(t>>>0)+(e>>>0)+(n>>>0)+(r>>>0),Wt=(t,e,n,r,o)=>e+n+r+o+(t/2**32|0)|0,zt=(t,e,n,r,o)=>(t>>>0)+(e>>>0)+(n>>>0)+(r>>>0)+(o>>>0),Xt=(t,e,n,r,o,s)=>e+n+r+o+s+(t/2**32|0)|0;var Wr=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),ce=new Uint32Array(64),ot=class extends be{constructor(e){super(64,e,8,!1)}get(){let{A:e,B:n,C:r,D:o,E:s,F:i,G:c,H:f}=this;return[e,n,r,o,s,i,c,f]}set(e,n,r,o,s,i,c,f){this.A=e|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=s|0,this.F=i|0,this.G=c|0,this.H=f|0}process(e,n){for(let u=0;u<16;u++,n+=4)ce[u]=e.getUint32(n,!1);for(let u=16;u<64;u++){let p=ce[u-15],b=ce[u-2],y=Q(p,7)^Q(p,18)^p>>>3,S=Q(b,17)^Q(b,19)^b>>>10;ce[u]=S+ce[u-7]+y+ce[u-16]|0}let{A:r,B:o,C:s,D:i,E:c,F:f,G:a,H:x}=this;for(let u=0;u<64;u++){let p=Q(c,6)^Q(c,11)^Q(c,25),b=x+p+et(c,f,a)+Wr[u]+ce[u]|0,S=(Q(r,2)^Q(r,13)^Q(r,22))+tt(r,o,s)|0;x=a,a=f,f=c,c=i+b|0,i=s,s=o,o=r,r=b+S|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,i=i+this.D|0,c=c+this.E|0,f=f+this.F|0,a=a+this.G|0,x=x+this.H|0,this.set(r,o,s,i,c,f,a,x)}roundClean(){X(ce)}destroy(){this.set(0,0,0,0,0,0,0,0),X(this.buffer)}},st=class extends ot{A=oe[0]|0;B=oe[1]|0;C=oe[2]|0;D=oe[3]|0;E=oe[4]|0;F=oe[5]|0;G=oe[6]|0;H=oe[7]|0;constructor(){super(32)}};var Pt=$t(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(t=>BigInt(t))),zr=Pt[0],Xr=Pt[1],fe=new Uint32Array(80),ae=new Uint32Array(80),it=class extends be{constructor(e){super(128,e,16,!1)}get(){let{Ah:e,Al:n,Bh:r,Bl:o,Ch:s,Cl:i,Dh:c,Dl:f,Eh:a,El:x,Fh:u,Fl:p,Gh:b,Gl:y,Hh:S,Hl:v}=this;return[e,n,r,o,s,i,c,f,a,x,u,p,b,y,S,v]}set(e,n,r,o,s,i,c,f,a,x,u,p,b,y,S,v){this.Ah=e|0,this.Al=n|0,this.Bh=r|0,this.Bl=o|0,this.Ch=s|0,this.Cl=i|0,this.Dh=c|0,this.Dl=f|0,this.Eh=a|0,this.El=x|0,this.Fh=u|0,this.Fl=p|0,this.Gh=b|0,this.Gl=y|0,this.Hh=S|0,this.Hl=v|0}process(e,n){for(let I=0;I<16;I++,n+=4)fe[I]=e.getUint32(n),ae[I]=e.getUint32(n+=4);for(let I=16;I<80;I++){let C=fe[I-15]|0,N=ae[I-15]|0,Z=xe(C,N,1)^xe(C,N,8)^rt(C,N,7),ue=pe(C,N,1)^pe(C,N,8)^nt(C,N,7),Y=fe[I-2]|0,R=ae[I-2]|0,re=xe(Y,R,19)^_e(Y,R,61)^rt(Y,R,6),P=pe(Y,R,19)^Oe(Y,R,61)^nt(Y,R,6),_=Yt(ue,P,ae[I-7],ae[I-16]),h=Wt(_,Z,re,fe[I-7],fe[I-16]);fe[I]=h|0,ae[I]=_|0}let{Ah:r,Al:o,Bh:s,Bl:i,Ch:c,Cl:f,Dh:a,Dl:x,Eh:u,El:p,Fh:b,Fl:y,Gh:S,Gl:v,Hh:L,Hl:q}=this;for(let I=0;I<80;I++){let C=xe(u,p,14)^xe(u,p,18)^_e(u,p,41),N=pe(u,p,14)^pe(u,p,18)^Oe(u,p,41),Z=u&b^~u&S,ue=p&y^~p&v,Y=zt(q,N,ue,Xr[I],ae[I]),R=Xt(Y,L,C,Z,zr[I],fe[I]),re=Y|0,P=xe(r,o,28)^_e(r,o,34)^_e(r,o,39),_=pe(r,o,28)^Oe(r,o,34)^Oe(r,o,39),h=r&s^r&c^s&c,l=o&i^o&f^i&f;L=S|0,q=v|0,S=b|0,v=y|0,b=u|0,y=p|0,{h:u,l:p}=te(a|0,x|0,R|0,re|0),a=c|0,x=f|0,c=s|0,f=i|0,s=r|0,i=o|0;let d=jt(re,_,l);r=Gt(d,R,P,h),o=d|0}({h:r,l:o}=te(this.Ah|0,this.Al|0,r|0,o|0)),{h:s,l:i}=te(this.Bh|0,this.Bl|0,s|0,i|0),{h:c,l:f}=te(this.Ch|0,this.Cl|0,c|0,f|0),{h:a,l:x}=te(this.Dh|0,this.Dl|0,a|0,x|0),{h:u,l:p}=te(this.Eh|0,this.El|0,u|0,p|0),{h:b,l:y}=te(this.Fh|0,this.Fl|0,b|0,y|0),{h:S,l:v}=te(this.Gh|0,this.Gl|0,S|0,v|0),{h:L,l:q}=te(this.Hh|0,this.Hl|0,L|0,q|0),this.set(r,o,s,i,c,f,a,x,u,p,b,y,S,v,L,q)}roundClean(){X(fe,ae)}destroy(){X(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}},ct=class extends it{Ah=M[0]|0;Al=M[1]|0;Bh=M[2]|0;Bl=M[3]|0;Ch=M[4]|0;Cl=M[5]|0;Dh=M[6]|0;Dl=M[7]|0;Eh=M[8]|0;El=M[9]|0;Fh=M[10]|0;Fl=M[11]|0;Gh=M[12]|0;Gl=M[13]|0;Hh=M[14]|0;Hl=M[15]|0;constructor(){super(64)}};var Ue=Ie(()=>new st,Fe(1));var ft=Ie(()=>new ct,Fe(3));var dt=BigInt(0),at=BigInt(1);function Le(t,e=""){if(typeof t!="boolean"){let n=e&&`"${e}" `;throw new Error(n+"expected boolean, got type="+typeof t)}return t}function Qt(t){if(typeof t=="bigint"){if(!$e(t))throw new Error("positive bigint expected, got "+t)}else ee(t);return t}function Ne(t){let e=Qt(t).toString(16);return e.length&1?"0"+e:e}function Jt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?dt:BigInt("0x"+t)}function Ee(t){return Jt(le(t))}function ut(t){return Jt(le(Pr(O(t)).reverse()))}function je(t,e){ee(e),t=Qt(t);let n=he(t.toString(16).padStart(e*2,"0"));if(n.length!==e)throw new Error("number too large");return n}function lt(t,e){return je(t,e).reverse()}function Pr(t){return Uint8Array.from(t)}var $e=t=>typeof t=="bigint"&&dt<=t;function Qr(t,e,n){return $e(t)&&$e(e)&&$e(n)&&e<=t&&t<n}function Ft(t,e,n,r){if(!Qr(e,n,r))throw new Error("expected valid "+t+": "+n+" <= n < "+r+", got "+e)}function ht(t){let e;for(e=0;t>dt;t>>=at,e+=1);return e}var Ce=t=>(at<<BigInt(t))-at;function er(t,e,n){if(ee(t,"hashLen"),ee(e,"qByteLen"),typeof n!="function")throw new Error("hmacFn must be a function");let r=v=>new Uint8Array(v),o=Uint8Array.of(),s=Uint8Array.of(0),i=Uint8Array.of(1),c=1e3,f=r(t),a=r(t),x=0,u=()=>{f.fill(1),a.fill(0),x=0},p=(...v)=>n(a,j(f,...v)),b=(v=o)=>{a=p(s,v),f=p(),v.length!==0&&(a=p(i,v),f=p())},y=()=>{if(x++>=c)throw new Error("drbg: tried max amount of iterations");let v=0,L=[];for(;v<e;){f=p();let q=f.slice();L.push(q),v+=f.length}return j(...L)};return(v,L)=>{u(),b(v);let q;for(;!(q=L(y()));)b();return u(),q}}function Te(t,e={},n={}){if(!t||typeof t!="object")throw new Error("expected valid options object");function r(s,i,c){let f=t[s];if(c&&f===void 0)return;let a=typeof f;if(a!==i||f===null)throw new Error(`param "${s}" is invalid: expected ${i}, got ${a}`)}let o=(s,i)=>Object.entries(s).forEach(([c,f])=>r(c,f,i));o(e,!1),o(n,!0)}function bt(t){let e=new WeakMap;return(n,...r)=>{let o=e.get(n);if(o!==void 0)return o;let s=t(n,...r);return e.set(n,s),s}}var W=BigInt(0),G=BigInt(1),we=BigInt(2),nr=BigInt(3),or=BigInt(4),sr=BigInt(5),Jr=BigInt(7),ir=BigInt(8),Fr=BigInt(9),cr=BigInt(16);function J(t,e){let n=t%e;return n>=W?n:e+n}function z(t,e,n){let r=t;for(;e-- >W;)r*=r,r%=n;return r}function tr(t,e){if(t===W)throw new Error("invert: expected non-zero number");if(e<=W)throw new Error("invert: expected positive modulus, got "+e);let n=J(t,e),r=e,o=W,s=G,i=G,c=W;for(;n!==W;){let a=r/n,x=r%n,u=o-i*a,p=s-c*a;r=n,n=x,o=i,s=c,i=u,c=p}if(r!==G)throw new Error("invert: does not exist");return J(o,e)}function pt(t,e,n){if(!t.eql(t.sqr(e),n))throw new Error("Cannot find square root")}function fr(t,e){let n=(t.ORDER+G)/or,r=t.pow(e,n);return pt(t,r,e),r}function en(t,e){let n=(t.ORDER-sr)/ir,r=t.mul(e,we),o=t.pow(r,n),s=t.mul(e,o),i=t.mul(t.mul(s,we),o),c=t.mul(s,t.sub(i,t.ONE));return pt(t,c,e),c}function tn(t){let e=Be(t),n=ar(t),r=n(e,e.neg(e.ONE)),o=n(e,r),s=n(e,e.neg(r)),i=(t+Jr)/cr;return(c,f)=>{let a=c.pow(f,i),x=c.mul(a,r),u=c.mul(a,o),p=c.mul(a,s),b=c.eql(c.sqr(x),f),y=c.eql(c.sqr(u),f);a=c.cmov(a,x,b),x=c.cmov(p,u,y);let S=c.eql(c.sqr(x),f),v=c.cmov(a,x,S);return pt(c,v,f),v}}function ar(t){if(t<nr)throw new Error("sqrt is not defined for small field");let e=t-G,n=0;for(;e%we===W;)e/=we,n++;let r=we,o=Be(t);for(;rr(o,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(n===1)return fr;let s=o.pow(r,e),i=(e+G)/we;return function(f,a){if(f.is0(a))return a;if(rr(f,a)!==1)throw new Error("Cannot find square root");let x=n,u=f.mul(f.ONE,s),p=f.pow(a,e),b=f.pow(a,i);for(;!f.eql(p,f.ONE);){if(f.is0(p))return f.ZERO;let y=1,S=f.sqr(p);for(;!f.eql(S,f.ONE);)if(y++,S=f.sqr(S),y===x)throw new Error("Cannot find square root");let v=G<<BigInt(x-y-1),L=f.pow(u,v);x=y,u=f.sqr(L),p=f.mul(p,u),b=f.mul(b,L)}return b}}function rn(t){return t%or===nr?fr:t%ir===sr?en:t%cr===Fr?tn(t):ar(t)}var nn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function wt(t){let e={ORDER:"bigint",BYTES:"number",BITS:"number"},n=nn.reduce((r,o)=>(r[o]="function",r),e);return Te(t,n),t}function on(t,e,n){if(n<W)throw new Error("invalid exponent, negatives unsupported");if(n===W)return t.ONE;if(n===G)return e;let r=t.ONE,o=e;for(;n>W;)n&G&&(r=t.mul(r,o)),o=t.sqr(o),n>>=G;return r}function Ge(t,e,n=!1){let r=new Array(e.length).fill(n?t.ZERO:void 0),o=e.reduce((i,c,f)=>t.is0(c)?i:(r[f]=i,t.mul(i,c)),t.ONE),s=t.inv(o);return e.reduceRight((i,c,f)=>t.is0(c)?i:(r[f]=t.mul(i,r[f]),t.mul(i,c)),s),r}function rr(t,e){let n=(t.ORDER-G)/we,r=t.pow(e,n),o=t.eql(r,t.ONE),s=t.eql(r,t.ZERO),i=t.eql(r,t.neg(t.ONE));if(!o&&!s&&!i)throw new Error("invalid Legendre symbol result");return o?1:s?0:-1}function sn(t,e){e!==void 0&&ee(e);let n=e!==void 0?e:t.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}var xt=class{ORDER;BITS;BYTES;isLE;ZERO=W;ONE=G;_lengths;_sqrt;_mod;constructor(e,n={}){if(e<=W)throw new Error("invalid field: expected ORDER > 0, got "+e);let r;this.isLE=!1,n!=null&&typeof n=="object"&&(typeof n.BITS=="number"&&(r=n.BITS),typeof n.sqrt=="function"&&(this.sqrt=n.sqrt),typeof n.isLE=="boolean"&&(this.isLE=n.isLE),n.allowedLengths&&(this._lengths=n.allowedLengths?.slice()),typeof n.modFromBytes=="boolean"&&(this._mod=n.modFromBytes));let{nBitLength:o,nByteLength:s}=sn(e,r);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=e,this.BITS=o,this.BYTES=s,this._sqrt=void 0,Object.preventExtensions(this)}create(e){return J(e,this.ORDER)}isValid(e){if(typeof e!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof e);return W<=e&&e<this.ORDER}is0(e){return e===W}isValidNot0(e){return!this.is0(e)&&this.isValid(e)}isOdd(e){return(e&G)===G}neg(e){return J(-e,this.ORDER)}eql(e,n){return e===n}sqr(e){return J(e*e,this.ORDER)}add(e,n){return J(e+n,this.ORDER)}sub(e,n){return J(e-n,this.ORDER)}mul(e,n){return J(e*n,this.ORDER)}pow(e,n){return on(this,e,n)}div(e,n){return J(e*tr(n,this.ORDER),this.ORDER)}sqrN(e){return e*e}addN(e,n){return e+n}subN(e,n){return e-n}mulN(e,n){return e*n}inv(e){return tr(e,this.ORDER)}sqrt(e){return this._sqrt||(this._sqrt=rn(this.ORDER)),this._sqrt(this,e)}toBytes(e){return this.isLE?lt(e,this.BYTES):je(e,this.BYTES)}fromBytes(e,n=!1){O(e);let{_lengths:r,BYTES:o,isLE:s,ORDER:i,_mod:c}=this;if(r){if(!r.includes(e.length)||e.length>o)throw new Error("Field.fromBytes: expected "+r+" bytes, got "+e.length);let a=new Uint8Array(o);a.set(e,s?0:a.length-e.length),e=a}if(e.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+e.length);let f=s?ut(e):Ee(e);if(c&&(f=J(f,i)),!n&&!this.isValid(f))throw new Error("invalid field element: outside of range 0..ORDER");return f}invertBatch(e){return Ge(this,e)}cmov(e,n,r){return r?n:e}};function Be(t,e={}){return new xt(t,e)}function dr(t){if(typeof t!="bigint")throw new Error("field order must be bigint");let e=t.toString(2).length;return Math.ceil(e/8)}function yt(t){let e=dr(t);return e+Math.ceil(e/2)}function gt(t,e,n=!1){O(t);let r=t.length,o=dr(e),s=yt(e);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);let i=n?ut(t):Ee(t),c=J(i,e-G)+G;return n?lt(c,o):je(c,o)}var ve=BigInt(0),ye=BigInt(1);function Ke(t,e){let n=e.negate();return t?n:e}function vt(t,e){let n=Ge(t.Fp,e.map(r=>r.Z));return e.map((r,o)=>t.fromAffine(r.toAffine(n[o])))}function br(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function mt(t,e){br(t,e);let n=Math.ceil(e/t)+1,r=2**(t-1),o=2**t,s=Ce(t),i=BigInt(t);return{windows:n,windowSize:r,mask:s,maxNumber:o,shiftBy:i}}function ur(t,e,n){let{windowSize:r,mask:o,maxNumber:s,shiftBy:i}=n,c=Number(t&o),f=t>>i;c>r&&(c-=s,f+=ye);let a=e*r,x=a+Math.abs(c)-1,u=c===0,p=c<0,b=e%2!==0;return{nextN:f,offset:x,isZero:u,isNeg:p,isNegF:b,offsetF:a}}var Et=new WeakMap,xr=new WeakMap;function Bt(t){return xr.get(t)||1}function lr(t){if(t!==ve)throw new Error("invalid wNAF")}var Ye=class{BASE;ZERO;Fn;bits;constructor(e,n){this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=n}_unsafeLadder(e,n,r=this.ZERO){let o=e;for(;n>ve;)n&ye&&(r=r.add(o)),o=o.double(),n>>=ye;return r}precomputeWindow(e,n){let{windows:r,windowSize:o}=mt(n,this.bits),s=[],i=e,c=i;for(let f=0;f<r;f++){c=i,s.push(c);for(let a=1;a<o;a++)c=c.add(i),s.push(c);i=c.double()}return s}wNAF(e,n,r){if(!this.Fn.isValid(r))throw new Error("invalid scalar");let o=this.ZERO,s=this.BASE,i=mt(e,this.bits);for(let c=0;c<i.windows;c++){let{nextN:f,offset:a,isZero:x,isNeg:u,isNegF:p,offsetF:b}=ur(r,c,i);r=f,x?s=s.add(Ke(p,n[b])):o=o.add(Ke(u,n[a]))}return lr(r),{p:o,f:s}}wNAFUnsafe(e,n,r,o=this.ZERO){let s=mt(e,this.bits);for(let i=0;i<s.windows&&r!==ve;i++){let{nextN:c,offset:f,isZero:a,isNeg:x}=ur(r,i,s);if(r=c,!a){let u=n[f];o=o.add(x?u.negate():u)}}return lr(r),o}getPrecomputes(e,n,r){let o=Et.get(n);return o||(o=this.precomputeWindow(n,e),e!==1&&(typeof r=="function"&&(o=r(o)),Et.set(n,o))),o}cached(e,n,r){let o=Bt(e);return this.wNAF(o,this.getPrecomputes(o,e,r),n)}unsafe(e,n,r,o){let s=Bt(e);return s===1?this._unsafeLadder(e,n,o):this.wNAFUnsafe(s,this.getPrecomputes(s,e,r),n,o)}createCache(e,n){br(n,this.bits),xr.set(e,n),Et.delete(e)}hasCache(e){return Bt(e)!==1}};function pr(t,e,n,r){let o=e,s=t.ZERO,i=t.ZERO;for(;n>ve||r>ve;)n&ye&&(s=s.add(o)),r&ye&&(i=i.add(o)),o=o.double(),n>>=ye,r>>=ye;return{p1:s,p2:i}}function hr(t,e,n){if(e){if(e.ORDER!==t)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return wt(e),e}else return Be(t,{isLE:n})}function wr(t,e,n={},r){if(r===void 0&&(r=t==="edwards"),!e||typeof e!="object")throw new Error(`expected valid ${t} CURVE object`);for(let f of["p","n","h"]){let a=e[f];if(!(typeof a=="bigint"&&a>ve))throw new Error(`CURVE.${f} must be positive bigint`)}let o=hr(e.p,n.Fp,r),s=hr(e.n,n.Fn,r),c=["Gx","Gy","a",t==="weierstrass"?"b":"d"];for(let f of c)if(!o.isValid(e[f]))throw new Error(`CURVE.${f} must be valid field element of CURVE.Fp`);return e=Object.freeze(Object.assign({},e)),{CURVE:e,Fp:o,Fn:s}}function yr(t,e){return function(r){let o=t(r);return{secretKey:o,publicKey:e(o)}}}var We=class{oHash;iHash;blockLen;outputLen;finished=!1;destroyed=!1;constructor(e,n){if(Ve(e),O(n,void 0,"key"),this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let r=this.blockLen,o=new Uint8Array(r);o.set(n.length>r?e.create().update(n).digest():n);for(let s=0;s<o.length;s++)o[s]^=54;this.iHash.update(o),this.oHash=e.create();for(let s=0;s<o.length;s++)o[s]^=106;this.oHash.update(o),X(o)}update(e){return me(this),this.iHash.update(e),this}digestInto(e){me(this),O(e,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){let e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||=Object.create(Object.getPrototypeOf(this),{});let{oHash:n,iHash:r,finished:o,destroyed:s,blockLen:i,outputLen:c}=this;return e=e,e.finished=o,e.destroyed=s,e.blockLen=i,e.outputLen=c,e.oHash=n._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},Ae=(t,e,n)=>new We(t,e).update(n).digest();Ae.create=(t,e)=>new We(t,e);var gr=(t,e)=>(t+(t>=0?e:-e)/mr)/e;function cn(t,e,n){let[[r,o],[s,i]]=e,c=gr(i*t,n),f=gr(-o*t,n),a=t-c*r-f*s,x=-c*o-f*i,u=a<se,p=x<se;u&&(a=-a),p&&(x=-x);let b=Ce(Math.ceil(ht(n)/2))+Se;if(a<se||a>=b||x<se||x>=b)throw new Error("splitScalar (endomorphism): failed, k="+t);return{k1neg:u,k1:a,k2neg:p,k2:x}}function St(t){if(!["compact","recovered","der"].includes(t))throw new Error('Signature format must be "compact", "recovered", or "der"');return t}function At(t,e){let n={};for(let r of Object.keys(e))n[r]=t[r]===void 0?e[r]:t[r];return Le(n.lowS,"lowS"),Le(n.prehash,"prehash"),n.format!==void 0&&St(n.format),n}var Rt=class extends Error{constructor(e=""){super(e)}},de={Err:Rt,_tlv:{encode:(t,e)=>{let{Err:n}=de;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length&1)throw new n("tlv.encode: unpadded data");let r=e.length/2,o=Ne(r);if(o.length/2&128)throw new n("tlv.encode: long form length too big");let s=r>127?Ne(o.length/2|128):"";return Ne(t)+s+o+e},decode(t,e){let{Err:n}=de,r=0;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length<2||e[r++]!==t)throw new n("tlv.decode: wrong tlv");let o=e[r++],s=!!(o&128),i=0;if(!s)i=o;else{let f=o&127;if(!f)throw new n("tlv.decode(long): indefinite length not supported");if(f>4)throw new n("tlv.decode(long): byte length is too big");let a=e.subarray(r,r+f);if(a.length!==f)throw new n("tlv.decode: length bytes not complete");if(a[0]===0)throw new n("tlv.decode(long): zero leftmost byte");for(let x of a)i=i<<8|x;if(r+=f,i<128)throw new n("tlv.decode(long): not minimal encoding")}let c=e.subarray(r,r+i);if(c.length!==i)throw new n("tlv.decode: wrong value length");return{v:c,l:e.subarray(r+i)}}},_int:{encode(t){let{Err:e}=de;if(t<se)throw new e("integer: negative integers are not allowed");let n=Ne(t);if(Number.parseInt(n[0],16)&8&&(n="00"+n),n.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return n},decode(t){let{Err:e}=de;if(t[0]&128)throw new e("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return Ee(t)}},toSig(t){let{Err:e,_int:n,_tlv:r}=de,o=O(t,void 0,"signature"),{v:s,l:i}=r.decode(48,o);if(i.length)throw new e("invalid signature: left bytes after parsing");let{v:c,l:f}=r.decode(2,s),{v:a,l:x}=r.decode(2,f);if(x.length)throw new e("invalid signature: left bytes after parsing");return{r:n.decode(c),s:n.decode(a)}},hexFromSig(t){let{_tlv:e,_int:n}=de,r=e.encode(2,n.encode(t.r)),o=e.encode(2,n.encode(t.s)),s=r+o;return e.encode(48,s)}},se=BigInt(0),Se=BigInt(1),mr=BigInt(2),ze=BigInt(3),fn=BigInt(4);function Er(t,e={}){let n=wr("weierstrass",t,e),{Fp:r,Fn:o}=n,s=n.CURVE,{h:i,n:c}=s;Te(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});let{endo:f}=e;if(f&&(!r.is0(s.a)||typeof f.beta!="bigint"||!Array.isArray(f.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');let a=vr(r,o);function x(){if(!r.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function u(_,h,l){let{x:d,y:w}=h.toAffine(),m=r.toBytes(d);if(Le(l,"isCompressed"),l){x();let B=!r.isOdd(w);return j(Br(B),m)}else return j(Uint8Array.of(4),m,r.toBytes(w))}function p(_){O(_,void 0,"Point");let{publicKey:h,publicKeyUncompressed:l}=a,d=_.length,w=_[0],m=_.subarray(1);if(d===h&&(w===2||w===3)){let B=r.fromBytes(m);if(!r.isValid(B))throw new Error("bad point: is not on curve, wrong x");let E=S(B),g;try{g=r.sqrt(E)}catch(k){let T=k instanceof Error?": "+k.message:"";throw new Error("bad point: is not on curve, sqrt error"+T)}x();let A=r.isOdd(g);return(w&1)===1!==A&&(g=r.neg(g)),{x:B,y:g}}else if(d===l&&w===4){let B=r.BYTES,E=r.fromBytes(m.subarray(0,B)),g=r.fromBytes(m.subarray(B,B*2));if(!v(E,g))throw new Error("bad point: is not on curve");return{x:E,y:g}}else throw new Error(`bad point: got length ${d}, expected compressed=${h} or uncompressed=${l}`)}let b=e.toBytes||u,y=e.fromBytes||p;function S(_){let h=r.sqr(_),l=r.mul(h,_);return r.add(r.add(l,r.mul(_,s.a)),s.b)}function v(_,h){let l=r.sqr(h),d=S(_);return r.eql(l,d)}if(!v(s.Gx,s.Gy))throw new Error("bad curve params: generator point");let L=r.mul(r.pow(s.a,ze),fn),q=r.mul(r.sqr(s.b),BigInt(27));if(r.is0(r.add(L,q)))throw new Error("bad curve params: a or b");function I(_,h,l=!1){if(!r.isValid(h)||l&&r.is0(h))throw new Error(`bad point coordinate ${_}`);return h}function C(_){if(!(_ instanceof R))throw new Error("Weierstrass Point expected")}function N(_){if(!f||!f.basises)throw new Error("no endo");return cn(_,f.basises,o.ORDER)}let Z=bt((_,h)=>{let{X:l,Y:d,Z:w}=_;if(r.eql(w,r.ONE))return{x:l,y:d};let m=_.is0();h==null&&(h=m?r.ONE:r.inv(w));let B=r.mul(l,h),E=r.mul(d,h),g=r.mul(w,h);if(m)return{x:r.ZERO,y:r.ZERO};if(!r.eql(g,r.ONE))throw new Error("invZ was invalid");return{x:B,y:E}}),ue=bt(_=>{if(_.is0()){if(e.allowInfinityPoint&&!r.is0(_.Y))return;throw new Error("bad point: ZERO")}let{x:h,y:l}=_.toAffine();if(!r.isValid(h)||!r.isValid(l))throw new Error("bad point: x or y not field elements");if(!v(h,l))throw new Error("bad point: equation left != right");if(!_.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function Y(_,h,l,d,w){return l=new R(r.mul(l.X,_),l.Y,l.Z),h=Ke(d,h),l=Ke(w,l),h.add(l)}class R{static BASE=new R(s.Gx,s.Gy,r.ONE);static ZERO=new R(r.ZERO,r.ONE,r.ZERO);static Fp=r;static Fn=o;X;Y;Z;constructor(h,l,d){this.X=I("x",h),this.Y=I("y",l,!0),this.Z=I("z",d),Object.freeze(this)}static CURVE(){return s}static fromAffine(h){let{x:l,y:d}=h||{};if(!h||!r.isValid(l)||!r.isValid(d))throw new Error("invalid affine point");if(h instanceof R)throw new Error("projective point not allowed");return r.is0(l)&&r.is0(d)?R.ZERO:new R(l,d,r.ONE)}static fromBytes(h){let l=R.fromAffine(y(O(h,void 0,"point")));return l.assertValidity(),l}static fromHex(h){return R.fromBytes(he(h))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(h=8,l=!0){return P.createCache(this,h),l||this.multiply(ze),this}assertValidity(){ue(this)}hasEvenY(){let{y:h}=this.toAffine();if(!r.isOdd)throw new Error("Field doesn't support isOdd");return!r.isOdd(h)}equals(h){C(h);let{X:l,Y:d,Z:w}=this,{X:m,Y:B,Z:E}=h,g=r.eql(r.mul(l,E),r.mul(m,w)),A=r.eql(r.mul(d,E),r.mul(B,w));return g&&A}negate(){return new R(this.X,r.neg(this.Y),this.Z)}double(){let{a:h,b:l}=s,d=r.mul(l,ze),{X:w,Y:m,Z:B}=this,E=r.ZERO,g=r.ZERO,A=r.ZERO,H=r.mul(w,w),k=r.mul(m,m),T=r.mul(B,B),U=r.mul(w,m);return U=r.add(U,U),A=r.mul(w,B),A=r.add(A,A),E=r.mul(h,A),g=r.mul(d,T),g=r.add(E,g),E=r.sub(k,g),g=r.add(k,g),g=r.mul(E,g),E=r.mul(U,E),A=r.mul(d,A),T=r.mul(h,T),U=r.sub(H,T),U=r.mul(h,U),U=r.add(U,A),A=r.add(H,H),H=r.add(A,H),H=r.add(H,T),H=r.mul(H,U),g=r.add(g,H),T=r.mul(m,B),T=r.add(T,T),H=r.mul(T,U),E=r.sub(E,H),A=r.mul(T,k),A=r.add(A,A),A=r.add(A,A),new R(E,g,A)}add(h){C(h);let{X:l,Y:d,Z:w}=this,{X:m,Y:B,Z:E}=h,g=r.ZERO,A=r.ZERO,H=r.ZERO,k=s.a,T=r.mul(s.b,ze),U=r.mul(l,m),K=r.mul(d,B),V=r.mul(w,E),F=r.add(l,d),D=r.add(m,B);F=r.mul(F,D),D=r.add(U,K),F=r.sub(F,D),D=r.add(l,w);let $=r.add(m,E);return D=r.mul(D,$),$=r.add(U,V),D=r.sub(D,$),$=r.add(d,w),g=r.add(B,E),$=r.mul($,g),g=r.add(K,V),$=r.sub($,g),H=r.mul(k,D),g=r.mul(T,V),H=r.add(g,H),g=r.sub(K,H),H=r.add(K,H),A=r.mul(g,H),K=r.add(U,U),K=r.add(K,U),V=r.mul(k,V),D=r.mul(T,D),K=r.add(K,V),V=r.sub(U,V),V=r.mul(k,V),D=r.add(D,V),U=r.mul(K,D),A=r.add(A,U),U=r.mul($,D),g=r.mul(F,g),g=r.sub(g,U),U=r.mul(F,K),H=r.mul($,H),H=r.add(H,U),new R(g,A,H)}subtract(h){return this.add(h.negate())}is0(){return this.equals(R.ZERO)}multiply(h){let{endo:l}=e;if(!o.isValidNot0(h))throw new Error("invalid scalar: out of range");let d,w,m=B=>P.cached(this,B,E=>vt(R,E));if(l){let{k1neg:B,k1:E,k2neg:g,k2:A}=N(h),{p:H,f:k}=m(E),{p:T,f:U}=m(A);w=k.add(U),d=Y(l.beta,H,T,B,g)}else{let{p:B,f:E}=m(h);d=B,w=E}return vt(R,[d,w])[0]}multiplyUnsafe(h){let{endo:l}=e,d=this;if(!o.isValid(h))throw new Error("invalid scalar: out of range");if(h===se||d.is0())return R.ZERO;if(h===Se)return d;if(P.hasCache(this))return this.multiply(h);if(l){let{k1neg:w,k1:m,k2neg:B,k2:E}=N(h),{p1:g,p2:A}=pr(R,d,m,E);return Y(l.beta,g,A,w,B)}else return P.unsafe(d,h)}toAffine(h){return Z(this,h)}isTorsionFree(){let{isTorsionFree:h}=e;return i===Se?!0:h?h(R,this):P.unsafe(this,c).is0()}clearCofactor(){let{clearCofactor:h}=e;return i===Se?this:h?h(R,this):this.multiplyUnsafe(i)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}toBytes(h=!0){return Le(h,"isCompressed"),this.assertValidity(),b(R,this,h)}toHex(h=!0){return le(this.toBytes(h))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}let re=o.BITS,P=new Ye(R,e.endo?Math.ceil(re/2):re);return R.BASE.precompute(8),R}function Br(t){return Uint8Array.of(t?2:3)}function vr(t,e){return{secretKey:e.BYTES,publicKey:1+t.BYTES,publicKeyUncompressed:1+2*t.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function an(t,e={}){let{Fn:n}=t,r=e.randomBytes||Me,o=Object.assign(vr(t.Fp,n),{seed:yt(n.ORDER)});function s(b){try{let y=n.fromBytes(b);return n.isValidNot0(y)}catch{return!1}}function i(b,y){let{publicKey:S,publicKeyUncompressed:v}=o;try{let L=b.length;return y===!0&&L!==S||y===!1&&L!==v?!1:!!t.fromBytes(b)}catch{return!1}}function c(b=r(o.seed)){return gt(O(b,o.seed,"seed"),n.ORDER)}function f(b,y=!0){return t.BASE.multiply(n.fromBytes(b)).toBytes(y)}function a(b){let{secretKey:y,publicKey:S,publicKeyUncompressed:v}=o;if(!Re(b)||"_lengths"in n&&n._lengths||y===S)return;let L=O(b,void 0,"key").length;return L===S||L===v}function x(b,y,S=!0){if(a(b)===!0)throw new Error("first arg must be private key");if(a(y)===!1)throw new Error("second arg must be public key");let v=n.fromBytes(b);return t.fromBytes(y).multiply(v).toBytes(S)}let u={isValidSecretKey:s,isValidPublicKey:i,randomSecretKey:c},p=yr(c,f);return Object.freeze({getPublicKey:f,getSharedSecret:x,keygen:p,Point:t,utils:u,lengths:o})}function Ar(t,e,n={}){Ve(e),Te(n,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),n=Object.assign({},n);let r=n.randomBytes||Me,o=n.hmac||((l,d)=>Ae(e,l,d)),{Fp:s,Fn:i}=t,{ORDER:c,BITS:f}=i,{keygen:a,getPublicKey:x,getSharedSecret:u,utils:p,lengths:b}=an(t,n),y={prehash:!0,lowS:typeof n.lowS=="boolean"?n.lowS:!0,format:"compact",extraEntropy:!1},S=c*mr<s.ORDER;function v(l){let d=c>>Se;return l>d}function L(l,d){if(!i.isValidNot0(d))throw new Error(`invalid signature ${l}: out of range 1..Point.Fn.ORDER`);return d}function q(){if(S)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function I(l,d){St(d);let w=b.signature,m=d==="compact"?w:d==="recovered"?w+1:void 0;return O(l,m)}class C{r;s;recovery;constructor(d,w,m){if(this.r=L("r",d),this.s=L("s",w),m!=null){if(q(),![0,1,2,3].includes(m))throw new Error("invalid recovery id");this.recovery=m}Object.freeze(this)}static fromBytes(d,w=y.format){I(d,w);let m;if(w==="der"){let{r:A,s:H}=de.toSig(O(d));return new C(A,H)}w==="recovered"&&(m=d[0],w="compact",d=d.subarray(1));let B=b.signature/2,E=d.subarray(0,B),g=d.subarray(B,B*2);return new C(i.fromBytes(E),i.fromBytes(g),m)}static fromHex(d,w){return this.fromBytes(he(d),w)}assertRecovery(){let{recovery:d}=this;if(d==null)throw new Error("invalid recovery id: must be present");return d}addRecoveryBit(d){return new C(this.r,this.s,d)}recoverPublicKey(d){let{r:w,s:m}=this,B=this.assertRecovery(),E=B===2||B===3?w+c:w;if(!s.isValid(E))throw new Error("invalid recovery id: sig.r+curve.n != R.x");let g=s.toBytes(E),A=t.fromBytes(j(Br((B&1)===0),g)),H=i.inv(E),k=Z(O(d,void 0,"msgHash")),T=i.create(-k*H),U=i.create(m*H),K=t.BASE.multiplyUnsafe(T).add(A.multiplyUnsafe(U));if(K.is0())throw new Error("invalid recovery: point at infinify");return K.assertValidity(),K}hasHighS(){return v(this.s)}toBytes(d=y.format){if(St(d),d==="der")return he(de.hexFromSig(this));let{r:w,s:m}=this,B=i.toBytes(w),E=i.toBytes(m);return d==="recovered"?(q(),j(Uint8Array.of(this.assertRecovery()),B,E)):j(B,E)}toHex(d){return le(this.toBytes(d))}}let N=n.bits2int||function(d){if(d.length>8192)throw new Error("input is too large");let w=Ee(d),m=d.length*8-f;return m>0?w>>BigInt(m):w},Z=n.bits2int_modN||function(d){return i.create(N(d))},ue=Ce(f);function Y(l){return Ft("num < 2^"+f,l,se,ue),i.toBytes(l)}function R(l,d){return O(l,void 0,"message"),d?O(e(l),void 0,"prehashed message"):l}function re(l,d,w){let{lowS:m,prehash:B,extraEntropy:E}=At(w,y);l=R(l,B);let g=Z(l),A=i.fromBytes(d);if(!i.isValidNot0(A))throw new Error("invalid private key");let H=[Y(A),Y(g)];if(E!=null&&E!==!1){let K=E===!0?r(b.secretKey):E;H.push(O(K,void 0,"extraEntropy"))}let k=j(...H),T=g;function U(K){let V=N(K);if(!i.isValidNot0(V))return;let F=i.inv(V),D=t.BASE.multiply(V).toAffine(),$=i.create(D.x);if($===se)return;let ke=i.create(F*i.create(T+$*A));if(ke===se)return;let Dt=(D.x===$?0:2)|Number(D.y&Se),qt=ke;return m&&v(ke)&&(qt=i.neg(ke),Dt^=1),new C($,qt,S?void 0:Dt)}return{seed:k,k2sig:U}}function P(l,d,w={}){let{seed:m,k2sig:B}=re(l,d,w);return er(e.outputLen,i.BYTES,o)(m,B).toBytes(w.format)}function _(l,d,w,m={}){let{lowS:B,prehash:E,format:g}=At(m,y);if(w=O(w,void 0,"publicKey"),d=R(d,E),!Re(l)){let A=l instanceof C?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+A)}I(l,g);try{let A=C.fromBytes(l,g),H=t.fromBytes(w);if(B&&A.hasHighS())return!1;let{r:k,s:T}=A,U=Z(d),K=i.inv(T),V=i.create(U*K),F=i.create(k*K),D=t.BASE.multiplyUnsafe(V).add(H.multiplyUnsafe(F));return D.is0()?!1:i.create(D.x)===k}catch{return!1}}function h(l,d,w={}){let{prehash:m}=At(w,y);return d=R(d,m),C.fromBytes(l,"recovered").recoverPublicKey(d).toBytes()}return Object.freeze({keygen:a,getPublicKey:x,getSharedSecret:u,utils:p,lengths:b,Point:t,sign:P,verify:_,recoverPublicKey:h,Signature:C,hash:e})}var It={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},dn={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]};var Sr=BigInt(2);function un(t){let e=It.p,n=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),i=BigInt(23),c=BigInt(44),f=BigInt(88),a=t*t*t%e,x=a*a*t%e,u=z(x,n,e)*x%e,p=z(u,n,e)*x%e,b=z(p,Sr,e)*a%e,y=z(b,o,e)*b%e,S=z(y,s,e)*y%e,v=z(S,c,e)*S%e,L=z(v,f,e)*v%e,q=z(L,c,e)*S%e,I=z(q,n,e)*x%e,C=z(I,i,e)*y%e,N=z(C,r,e)*a%e,Z=z(N,Sr,e);if(!Ht.eql(Ht.sqr(Z),t))throw new Error("Cannot find square root");return Z}var Ht=Be(It.p,{sqrt:un}),ln=Er(It,{Fp:Ht,endo:dn}),ge=Ar(ln,Ue);var hn=Uint8Array.from([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),Hr=Uint8Array.from(new Array(16).fill(0).map((t,e)=>e)),bn=Hr.map(t=>(9*t+5)%16),Ir=(()=>{let n=[[Hr],[bn]];for(let r=0;r<4;r++)for(let o of n)o.push(o[r].map(s=>hn[s]));return n})(),_r=Ir[0],Or=Ir[1],Ur=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(t=>Uint8Array.from(t)),xn=_r.map((t,e)=>t.map(n=>Ur[e][n])),pn=Or.map((t,e)=>t.map(n=>Ur[e][n])),wn=Uint32Array.from([0,1518500249,1859775393,2400959708,2840853838]),yn=Uint32Array.from([1352829926,1548603684,1836072691,2053994217,0]);function Rr(t,e,n,r){return t===0?e^n^r:t===1?e&n|~e&r:t===2?(e|~n)^r:t===3?e&r|n&~r:e^(n|~r)}var Xe=new Uint32Array(16),_t=class extends be{h0=1732584193;h1=-271733879;h2=-1732584194;h3=271733878;h4=-1009589776;constructor(){super(64,20,8,!0)}get(){let{h0:e,h1:n,h2:r,h3:o,h4:s}=this;return[e,n,r,o,s]}set(e,n,r,o,s){this.h0=e|0,this.h1=n|0,this.h2=r|0,this.h3=o|0,this.h4=s|0}process(e,n){for(let b=0;b<16;b++,n+=4)Xe[b]=e.getUint32(n,!0);let r=this.h0|0,o=r,s=this.h1|0,i=s,c=this.h2|0,f=c,a=this.h3|0,x=a,u=this.h4|0,p=u;for(let b=0;b<5;b++){let y=4-b,S=wn[b],v=yn[b],L=_r[b],q=Or[b],I=xn[b],C=pn[b];for(let N=0;N<16;N++){let Z=He(r+Rr(b,s,c,a)+Xe[L[N]]+S,I[N])+u|0;r=u,u=a,a=He(c,10)|0,c=s,s=Z}for(let N=0;N<16;N++){let Z=He(o+Rr(y,i,f,x)+Xe[q[N]]+v,C[N])+p|0;o=p,p=x,x=He(f,10)|0,f=i,i=Z}}this.set(this.h1+c+x|0,this.h2+a+p|0,this.h3+u+o|0,this.h4+r+i|0,this.h0+s+f|0)}roundClean(){X(Xe)}destroy(){this.destroyed=!0,X(this.buffer),this.set(0,0,0,0,0)}},Lr=Ie(()=>new _t);function Ot(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function Cr(t,e){return Array.isArray(e)?e.length===0?!0:t?e.every(n=>typeof n=="string"):e.every(n=>Number.isSafeInteger(n)):!1}function gn(t){if(typeof t!="function")throw new Error("function expected");return!0}function Ut(t,e){if(typeof e!="string")throw new Error(`${t}: string expected`);return!0}function Nt(t){if(!Number.isSafeInteger(t))throw new Error(`invalid integer: ${t}`)}function Lt(t){if(!Array.isArray(t))throw new Error("array expected")}function Tr(t,e){if(!Cr(!0,e))throw new Error(`${t}: array of strings expected`)}function mn(t,e){if(!Cr(!1,e))throw new Error(`${t}: array of numbers expected`)}function Kr(...t){let e=s=>s,n=(s,i)=>c=>s(i(c)),r=t.map(s=>s.encode).reduceRight(n,e),o=t.map(s=>s.decode).reduce(n,e);return{encode:r,decode:o}}function En(t){let e=typeof t=="string"?t.split(""):t,n=e.length;Tr("alphabet",e);let r=new Map(e.map((o,s)=>[o,s]));return{encode:o=>(Lt(o),o.map(s=>{if(!Number.isSafeInteger(s)||s<0||s>=n)throw new Error(`alphabet.encode: digit index outside alphabet "${s}". Allowed: ${t}`);return e[s]})),decode:o=>(Lt(o),o.map(s=>{Ut("alphabet.decode",s);let i=r.get(s);if(i===void 0)throw new Error(`Unknown letter: "${s}". Allowed: ${t}`);return i}))}}function Bn(t=""){return Ut("join",t),{encode:e=>(Tr("join.decode",e),e.join(t)),decode:e=>(Ut("join.decode",e),e.split(t))}}function Nr(t,e,n){if(e<2)throw new Error(`convertRadix: invalid from=${e}, base cannot be less than 2`);if(n<2)throw new Error(`convertRadix: invalid to=${n}, base cannot be less than 2`);if(Lt(t),!t.length)return[];let r=0,o=[],s=Array.from(t,c=>{if(Nt(c),c<0||c>=e)throw new Error(`invalid integer: ${c}`);return c}),i=s.length;for(;;){let c=0,f=!0;for(let a=r;a<i;a++){let x=s[a],u=e*c,p=u+x;if(!Number.isSafeInteger(p)||u/e!==c||p-x!==u)throw new Error("convertRadix: carry overflow");let b=p/n;c=p%n;let y=Math.floor(b);if(s[a]=y,!Number.isSafeInteger(y)||y*n+c!==p)throw new Error("convertRadix: carry overflow");if(f)y?f=!1:r=a;else continue}if(o.push(c),f)break}for(let c=0;c<t.length-1&&t[c]===0;c++)o.push(0);return o.reverse()}function vn(t){Nt(t);let e=2**8;return{encode:n=>{if(!Ot(n))throw new Error("radix.encode input should be Uint8Array");return Nr(Array.from(n),e,t)},decode:n=>(mn("radix.decode",n),Uint8Array.from(Nr(n,t,e)))}}function An(t,e){return Nt(t),gn(e),{encode(n){if(!Ot(n))throw new Error("checksum.encode: input should be Uint8Array");let r=e(n).slice(0,t),o=new Uint8Array(n.length+t);return o.set(n),o.set(r,n.length),o},decode(n){if(!Ot(n))throw new Error("checksum.decode: input should be Uint8Array");let r=n.slice(0,-t),o=n.slice(-t),s=e(r).slice(0,t);for(let i=0;i<t;i++)if(s[i]!==o[i])throw new Error("Invalid checksum");return r}}}var Sn=t=>Kr(vn(58),En(t),Bn("")),Rn=Sn("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");var Dr=t=>Kr(An(4,e=>t(t(e))),Rn);var qe=ge.Point,{Fn:De}=qe,Ct=Dr(Ue),Hn=Uint8Array.from("Bitcoin seed".split(""),t=>t.charCodeAt(0)),Tt={private:76066276,public:76067358},Kt=2147483648,In=t=>Lr(Ue(t)),_n=t=>ie(t).getUint32(0,!1),Pe=t=>{if(!Number.isSafeInteger(t)||t<0||t>2**32-1)throw new Error("invalid number, should be from 0 to 2**32-1, got "+t);let e=new Uint8Array(4);return ie(e).setUint32(0,t,!1),e},Qe=class t{get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return _n(this.pubHash)}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this._privateKey||null}get publicKey(){return this._publicKey||null}get privateExtendedKey(){let e=this._privateKey;if(!e)throw new Error("No private key");return Ct.encode(this.serialize(this.versions.private,j(Uint8Array.of(0),e)))}get publicExtendedKey(){if(!this._publicKey)throw new Error("No public key");return Ct.encode(this.serialize(this.versions.public,this._publicKey))}static fromMasterSeed(e,n=Tt){if(O(e),8*e.length<128||8*e.length>512)throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got "+e.length);let r=Ae(ft,Hn,e),o=r.slice(0,32),s=r.slice(32);return new t({versions:n,chainCode:s,privateKey:o})}static fromExtendedKey(e,n=Tt){let r=Ct.decode(e),o=ie(r),s=o.getUint32(0,!1),i={versions:n,depth:r[4],parentFingerprint:o.getUint32(5,!1),index:o.getUint32(9,!1),chainCode:r.slice(13,45)},c=r.slice(45),f=c[0]===0;if(s!==n[f?"private":"public"])throw new Error("Version mismatch");return f?new t({...i,privateKey:c.slice(1)}):new t({...i,publicKey:c})}static fromJSON(e){return t.fromExtendedKey(e.xpriv)}versions;depth=0;index=0;chainCode=null;parentFingerprint=0;_privateKey;_publicKey;pubHash;constructor(e){if(!e||typeof e!="object")throw new Error("HDKey.constructor must not be called directly");if(this.versions=e.versions||Tt,this.depth=e.depth||0,this.chainCode=e.chainCode||null,this.index=e.index||0,this.parentFingerprint=e.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(this.depth>255)throw new Error("HDKey: depth exceeds the serializable value 255");if(e.publicKey&&e.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(e.privateKey){if(!ge.utils.isValidSecretKey(e.privateKey))throw new Error("Invalid private key");this._privateKey=e.privateKey,this._publicKey=ge.getPublicKey(e.privateKey,!0)}else if(e.publicKey)this._publicKey=qe.fromBytes(e.publicKey).toBytes(!0);else throw new Error("HDKey: no public or private key provided");this.pubHash=In(this._publicKey)}derive(e){if(!/^[mM]'?/.test(e))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(e))return this;let n=e.replace(/^[mM]'?\//,"").split("/"),r=this;for(let o of n){let s=/^(\d+)('?)$/.exec(o),i=s&&s[1];if(!s||s.length!==3||typeof i!="string")throw new Error("invalid child index: "+o);let c=+i;if(!Number.isSafeInteger(c)||c>=Kt)throw new Error("Invalid index");s[2]==="'"&&(c+=Kt),r=r.deriveChild(c)}return r}deriveChild(e){if(!this._publicKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let n=Pe(e);if(e>=Kt){let f=this._privateKey;if(!f)throw new Error("Could not derive hardened child key");n=j(Uint8Array.of(0),f,n)}else n=j(this._publicKey,n);let r=Ae(ft,this.chainCode,n),o=r.slice(0,32),s=r.slice(32);if(!ge.utils.isValidSecretKey(o))throw new Error("Tweak bigger than curve order");let i={versions:this.versions,chainCode:s,depth:this.depth+1,parentFingerprint:this.fingerprint,index:e},c=De.fromBytes(o);try{if(this._privateKey){let f=De.create(De.fromBytes(this._privateKey)+c);if(!De.isValidNot0(f))throw new Error("The tweak was out of range or the resulted private key is invalid");i.privateKey=De.toBytes(f)}else{let f=qe.fromBytes(this._publicKey).add(qe.BASE.multiply(c));if(f.equals(qe.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");i.publicKey=f.toBytes(!0)}return new t(i)}catch{return this.deriveChild(e+1)}}sign(e){if(!this._privateKey)throw new Error("No privateKey set!");return O(e,32),ge.sign(e,this._privateKey,{prehash:!1})}verify(e,n){if(O(e,32),O(n,64),!this._publicKey)throw new Error("No publicKey set!");return ge.verify(n,e,this._publicKey,{prehash:!1})}wipePrivateData(){return this._privateKey&&(this._privateKey.fill(0),this._privateKey=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(e,n){if(!this.chainCode)throw new Error("No chainCode set");return O(n,33),j(Pe(e),new Uint8Array([this.depth]),Pe(this.parentFingerprint),Pe(this.index),this.chainCode,n)}};return $r(On);})();
/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
